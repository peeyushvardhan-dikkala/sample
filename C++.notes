C++

1) Why C++ is better than Java?
C++ is often considered better than Java for several reasons, especially in performance-critical applications:
1) Performance:
C++ compiles directly to machine code, which means it runs faster than Java, which runs on the Java Virtual Machine (JVM).
C++ allows for low-level memory management, giving you control over how memory is allocated and deallocated.
This can lead to more efficient use of resources, especially in systems programming or real-time applications.
2) Memory Management:
C++ uses manual memory management with `new` and `delete`, allowing for precise control over memory allocation.
You can optimize memory usage and avoid garbage collection pauses that can occur in Java.
3) Real-time Systems:
C++ is often preferred for real-time systems where predictable performance is crucial.
Java's garbage collector can introduce unpredictable latency, which is not suitable for real-time applications.
4) System-Level Programming:
C++ is widely used for system-level programming, such as operating systems, embedded systems, and game development.
It provides low-level access to hardware and system resources, making it ideal for performance-critical applications.
5) Portability:
C++ code can be compiled on any platform with a C++ compiler, making it portable across different systems.
Java is also portable, but it requires the JVM to run, which adds an extra layer of abstraction.

In C++, you can avoid any memory allocation during runtime and ensure constant-time operations.
In Java, even with tuning, a garbage collection pause could introduce unpredictable latency ‚Äî bad for real-time systems.
Java programs run on the Java Virtual Machine (JVM), which adds a layer between your code and the hardware. This offers portability and safety, but also introduces some performance overhead,

2) Memory Layout: 
High Address
+--------------------+
|      Stack         | 
|--------------------|
|      Heap          | 
|--------------------|
| .bss  (zero init)  |
| .data (initialized)| 
| .rodata (const)    | ‚Üê "hello"
| .text (code)       | 
+--------------------+
Low Address

+-------------------------+
|       Stack            | ‚Üê Local vars, function calls , Grows Downward
+-------------------------+
|       Heap             | ‚Üê new/malloc , Grows Upward
+-------------------------+
|   Uninitialized Data   | ‚Üê int x;
|      (BSS Segment)     | 
+-------------------------+
|   Initialized Data     |
|     (Data Segment)     |‚Üê int x = 5;
+-------------------------+
|     Read-Only Data     |
|       (.rodata)        |
+-------------------------+
|       Text             |‚Üê main(), func()
|   (Code Segment)       |
+-------------------------+

    a) Stack:
Stack is where local variables and function calls are stored. It grows downwards in memory.
The stack area traditionally adjoined the heap area, but modern systems may have them separated.
When the stack runs out of space, it can lead to a stack overflow.
When the stack pointer met the heap pointer, it can lead to a stack overflow.
It is in LIFO structure (Last In First Out), meaning the last function called is the first to return.
The stack pointer (SP) points to the top of the stack, and it grows downwards in memory.
The set of values in the stack is called a stack frame, which contains:
- Function arguments
- Local variables
- Return address
- Function call/return tracking
 - Function call/return tracking via the stack means:
    When a function is called, the CPU uses the stack to remember:
        Where to return
        What values (args, locals) to use
    When the function returns, it pops that info off and resumes normally.
Managed automatically by the compiler.
b) Heap:
Heap is where dynamically allocated memory (using `new` or `malloc`) is stored. It grows upwards in memory.
The heap is used for objects that need to persist beyond the scope of a function call.
It is managed manually by the programmer, meaning you must allocate and deallocate memory explicitly.
When you allocate memory on the heap, you must remember to free it to avoid memory leaks. Using `delete` or `free` is essential to release memory back to the system.

c) .bss, .data, .rodata, .text:
These are sections of the program's memory layout:
- **.bss (Block Started by Symbol):**: Contains uninitialized global and static variables. It is zero-initialized by the system.
- **.data**: Contains initialized global and static variables.
- **.rodata**: Contains read-only data, such as string literals or constant values.
- **.text**: Stores compiled instructions from your source code, including functions and methods.

Eg: global const char* str = "hello world";
The string literal "hello world" is stored in the `.rodata` section, which is read-only.
The pointer variable str is in the initialized data segment(i.e., read-write memory).

.text vs Stack:
The `.text` section contains the actual compiled code of your program, while the stack is used for managing function calls and local variables.
The `.text` section is static and does not change during program execution, while the stack grows and shrinks dynamically as functions are called and return.

.text Includes things like:
main()
any other functions
inline assembly
It's read-only for safety (accidentally writing here = crash).

2)Why we should learn C++ ?
I chose to learn C++ because it gives me a deep understanding of how computers manage memory and resources, and it builds a strong foundation in core programming concepts that apply across all languages.

C++ teaches you:
How memory works (new, delete, pointers)
What compilers and linkers do

C++ is extremely fast ‚Äî often faster than Java, Python, or JavaScript ‚Äî because:
It compiles to machine code
There's no garbage collector slowing things down
You optimize your own memory

Machine code is platform-specific: An .exe compiled on Windows won't run on Linux unless recompiled.
But the source code can be compiled on any machine with a C++ compiler.
Can be recompiled or interpreted anywhere

A machine-independent language (like C++, Java, or Python) can run on any machine ‚Äî as long as there is the right compiler or interpreter for that platform.

2) Tokens in Cpp:
Tokens are the basic units in a C++ program, like words in a sentence. 
A lexical token is a sequence of characters that can be treated as a unit in the grammar of the programming languages.
King Is Computing Some Overloaded Programs

| Token Type                      | Example                        | Description                                      |
| ------------------------------- | ------------------------------ | ------------------------------------------------ |
| **1. Keywords**                 | `int`, `return`, `if`, `while` | Reserved words in C++ with special meaning       |
| **2. Identifiers**              | `main`, `myVariable`, `sum`    | Names given to variables, functions, classes     |
| **3. Constants / Literals**     | `10`, `3.14`, `'A'`, `"Hello"` | Fixed values                                     |
| **4. Strings**                  | `"Hello World"`                | Sequence of characters enclosed in double quotes |
| **5. Operators**                | `+`, `-`, `*`, `=`, `==`       | Perform operations (math, logical, etc.)         |
| **6. Punctuators / Separators** | `;`, `{}`, `()`, `,`           | Symbols used to structure code                   |

3) The C++ compiler processes your source code in several phases, each transforming the code into a more machine-friendly format. Here‚Äôs a simplified overview of the main phases:
1. **Lexical Analysis**: The compiler reads the source code and breaks it down into tokens, which are the smallest units of meaning (like keywords, identifiers, operators, etc.).
2. **Syntax Analysis (Parsing)**: The compiler checks the grammar of the code, ensuring it follows the rules of the C++ language. It builds a parse tree or abstract syntax tree (AST) to represent the structure of the code.
3. **Semantic Analysis**: The compiler checks the meaning of the code, ensuring that types are correct, variables are declared before use, and other semantic rules are followed. It may also perform type checking and scope resolution.
4. **Intermediate Code Generation**: The compiler converts the AST into an intermediate representation (IR), which is a lower-level, machine-neutral code that is easier to optimize and translate into machine code.
5. **Optimization (Optional)**: The compiler may optimize the intermediate code to improve performance without changing the program's meaning. This can include removing unnecessary code, inlining functions, or optimizing loops.
6. **Code Generation & Linking**: The compiler translates the optimized intermediate code into machine code specific to the target CPU architecture. It produces an executable file (like `.exe` or `.out`) and may link it with libraries or other object files to resolve external references.
This process ensures that your C++ code is transformed into an efficient executable that can run on your computer.  
7. **Error Handling**: Throughout these phases, the compiler checks for errors and warnings, providing feedback to the programmer about issues in the code that need to be fixed before successful compilation.
Here‚Äôs a visual representation of the C++ compilation process:    
Here‚Äôs a visual representation of the C++ compilation process:
           üîΩ Your C++ Source Code (main.cpp)
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ--------‚îê
              ‚îÇ 1. Lexical Analysis: Breaks code into tokens        ‚îÇ  
              ‚îÇ 2. Syntax Analysis: Checks grammar, builds AST      ‚îÇ
              ‚îÇ 3. Semantic Analysis: Validates meaning, types      ‚îÇ
              ‚îÇ 4. Intermediate Code Generation: Converts AST to IR ‚îÇ
              ‚îÇ 5. Optimization: Improves performance (optional)    ‚îÇ
              ‚îÇ 6. Code Generation & Linking: Produces executable   ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ---------‚îÄ‚îò
When we say "intermediate code generation" (step 4), we mean that the compiler transforms the Abstract Syntax Tree (AST) into a more machine-friendly, intermediate representation (IR), which is a step closer to machine code ‚Äî but still not quite hardware-specific.
 
4)we mean that the compiler transforms the Abstract Syntax Tree (AST) into a more machine-friendly, intermediate representation (IR), which is a step closer to machine code ‚Äî but still not quite hardware-specific.

Comments in C++:

Comments in C++ are meant to explain the code as well as to make it more readable. Their purpose is to provide information about code lines. Programmers commonly use comments to document their work
// Single lines Use Ctrl+/
/* Multiline Comment */ 

5) Variables in C++:
A variable is a name given to a memory location. It is used to store data that can be changed during program execution.

Rules for naming variables:
1. Must begin with a letter (A-Z, a-z) or an underscore (_).
2. Can contain letters, digits (0-9), and underscores.
3. Cannot be a reserved keyword, special keyword in C++ (like int, return, if, etc.).
4. Variable names are case-sensitive (e.g., myVar and MyVar are different).

Scope controls where a variable can be accessed; lifetime controls how long it exists in memory.

Depending on where and how they are declared, variables can have different scopes, lifetimes, and memory areas.

| **Type**                   | **Declared**                   | **Scope**               | **Lifetime**                   | **Memory Area**                                    |
| -------------------------- | ------------------------------ | ----------------------- | ------------------------------ | -------------------------------------------------- |
| **Local Variable**         | Inside a function/block        | Within that block       | Created & destroyed with block | **Stack**                                          |
| **Global Variable**        | Outside all functions          | Whole program           | Entire program                 | **.data** (initialized) / **.bss** (uninitialized) |

Static Variables:
| **Static Local Variable**  | Inside function with `static`  | Only that function      | Whole program, retains value   | **.data / .bss**                                   |
| **Static Global Variable** | Outside function with `static` | File (translation unit) | Entire program                 | **.data / .bss**                                   |

External Variables:
extern does not allocate memory.
It only tells compiler: ‚Äúvalue is defined somewhere else.‚Äù
| **External Variable**      | Outside function with `extern` | Whole program           | Entire program                 | **.data / .bss**                                   |

Register Variables:
Hint to compiler to store variable in CPU register for speed.
Modern compilers ignore this; it's just a suggestion.
You cannot take address of register variable because it may not have a memory address.

| **Register Variable**      | Inside function with `register`| Only that function      | Created & destroyed with block | **CPU Registers** (if available)                   |

Class Member Variables:
| **Instance Variable**      | Inside class (no `static`)     | Per object              | As long as object exists       | **Object's memory** (stack/heap)                   |
| **Static Member Variable** | Inside class with `static`     | Shared by all objects   | Entire program                 | **.data / .bss**                                   |
| **Local Variables **       | Inside member function         | Only that function      | Created & destroyed with block | **Stack**                                          |
(Inside member functions)

Storage Classes:
Storage classes in C++ define the scope (visibility) and lifetime of variables and functions within a program. They determine how and where the variables are stored in memory, as well as their accessibility.
A storage class in C++ defines four main properties of a variable:
Scope ‚Üí Where the variable is accessible
Lifetime ‚Üí How long it exists in memory
Default value
Memory location

| **Storage Class** | **Keyword** | **Scope**  | **Lifetime** | **Memory Area** | **Default Value** |
| ----------------- | ----------- | ---------- | ------------ | --------------- | ----------------- |
| **Automatic**     | `auto`      | Local      | Block        | Stack           | Garbage           |
| **Register**      | `register`  | Local      | Block        | CPU Register    | Garbage           |
| **Static**        | `static`    | Local/File | Program      | .data / .bss    | 0                 |
| **External**      | `extern`    | Global     | Program      | .data / .bss    | 0                 |

Type Qualifiers:
Type qualifiers in C++ are keywords that modify the behavior of variables, objects, or functions. They do NOT change the type itself but change the properties or rules applied to it.

1) const
2) volatile
3) mutable
4) restrict / restrict (compiler-specific)
5) constexpr / consteval / constinit (C++11 and later)

1) const keyword:
It is read only qualifier means the value cannot be changed after initialization.
2) volatile keyword:
It tells the compiler that a variable's value may change unexpectedly(hardware, interrupts, threads), Don't optimize it.
3) mutable keyword:
const object is an object that cannot be modified after its creation. However, there are scenarios where you might want to allow certain member variables of a const object to be modified. 
Eg: Application settings loaded at startup. You don't want the settings to be accidentally modified during runtime. We can make accessCount as mutuable to check how many times settings were accessed, even in a const object.

Allows a non-static data member of a class to be modified even in a const object or inside a const member function.

4) restrict keyword:
It is a pointer qualifier that indicates this pointer is the only pointer that will access this memory location.
Because there is no other pointer using the same memory, the compiler can make optimizations based on this guarantee.

5) constexpr :
constexpr is a keyword in C++ that tells the compiler: "This value/function can be evaluated at compile time."
It helps with optimization and ensures immutability like const, but with added compile-time power.
Used to define compile-time constants.
Can be used in contexts that require compile-time evaluation, like template parameters or array sizes.

constexpr is used for functions used as a specifier that indicates the function can be evaluated at compile time if all its arguments are also known at compile time.

consteval(C++20):
The values must be evaluated at compile time.
Applied only to functions.
If not possible ‚Üí compile-time error.

consteval int cube(int n) {
    return n * n * n;
}

int x = cube(3);   // OK ‚Üí compile-time evaluation
int n;
std::cin >> n;
// int y = cube(n);  // ‚ùå ERROR: cannot call consteval at runtime

constinit(C++20):
The variable must be initialized at compile time.
It is used for global/static variables ensures that a variable is initialized at compile time, but unlike `consteval`, it does not require the value to be a compile-time constant.

constinit int a = 10;   // must be initialized at compile time
a = 20;                 // ‚úî allowed, not const

constinit static int x = 5;   // OK
// constinit int y;           // ‚ùå ERROR: not initialized


C++ Data types:
Data types specify the type of data that a variable can store. Whenever a variable is defined in C++, the compiler allocates some memory for that variable based on the data.

1) Built-in (Primitive) Data Type
    a) Integral Types --> bool, char, wchar_t, short, int, long, long long
    b) Floating Point Types --> float, double, long double
    c) Void Type --> void
2) Derived Data Types --> Pointers, Arrays, References, Functions - int func(int a)
3) User-defined Data Types --> struct, class, union, enum, typedef, using

Modifiers:
Modifiers are keywords used with data types to alter the size, range, or sign of the variables.
| **Modifier** | **Meaning**                                                  |
| ------------ | ------------------------------------------------------------ |
| `short`      | Reduces the size of an integer type                          |
| `long`       | Increases the size of an integer or double type              |
| `signed`     | Allows both positive and negative values                     |
| `unsigned`   | Allows only non-negative values (doubles the positive range) |

Modifiers can be applied to: int, char, double (only with long)
They cannot be used with float, bool, or user-defined types.

4) Modern CPUs are designed to read memory in fixed-size chunks, often called words. The size of these chunks depends on the CPU architecture:
| CPU Architecture | Word Size | Typical Chunk           |
| ---------------- | --------- | ----------------------- |
| 32-bit           | 4 bytes   | Reads 4 bytes at a time |
| 64-bit           | 8 bytes   | Reads 8 bytes at a time |

| Data Type     | Size (Typical) | Description                            |
| ------------- | -------------- | -------------------------------------- |
| `bool`        | 1 byte         | Boolean value (`true` or `false`)      |
| `char`        | 1 byte         | Single character (ASCII)               |
| `wchar_t`     | 2 or 4 bytes   | Wide character (Unicode) Eg: `L'A'`  |             
| `short`       | 2 bytes        | Short integer                          |
| `int`         | 4 bytes        | Standard integer                       |
| `float`       | 4 bytes        | Single-precision floating-point        |
| `long`        | 4 or 8 bytes   | Long integer (platform-dependent)      |
| `long long`   | 8 bytes        | Larger integer                         |
| `double`      | 8 bytes        | Double-precision floating-point        |
| `long double` | 8, 12, or 16 B | Extended precision (compiler-specific) |
| `void`        | 0 bytes        | No value / empty type                  |

bool vs bool_t :
In C++, `bool` is a built-in data type that represents boolean values (`true` or `false`). It is used for logical operations and conditions.
`bool_t` is not a standard C++ type; it might be defined in some libraries or frameworks as a typedef or alias for `bool`, but it is not part of the C++ standard.  
Used in legacy C is `typedef int bool_t;` to represent boolean values, but this is not recommended in modern C++.
// and can lead to confusion. In modern C++, always use `bool` for boolean values.
// and to optimize memory access patterns for better performance.
// In C++, the `bool` type is typically 1 byte, but it can be larger depending on the compiler and platform.
// The `bool_t` type is not standard in C++ and may refer to a custom type defined in some libraries or frameworks.
// or in C as `typedef int bool_t;` to represent boolean values, but this is not recommended in modern C++.

7) In C++, string is a class from the STL that manages dynamic character arrays.
std::string internally holds a pointer to a dynamically allocated character array on the heap. This allows the string to manage memory flexibly as its size changes. The object on the stack only stores metadata ‚Äî like the pointer, size, and capacity ‚Äî not the actual characters.

8) Why Is Padding Necessary in C++? 
Padding in C++ refers to the insertion of unused bytes between members of a structure or class to ensure proper memory alignment

Padding is necessary to maintain proper memory alignment for data members within a structure or class.

Most modern CPUs require that data types be stored at memory addresses that are multiples of their size ‚Äî for example, a 4-byte int should start at an address divisible by 4. If this alignment is not respected, the CPU may need extra cycles to access the data can result in slower access times, or on some systems, it may result in a crash due to misaligned access.

By carefully ordering members within a structure (placing larger types first), it is possible to reduce the amount of padding required, resulting in more efficient memory usage

9) Imagine you are a librarian handling a list of books. You have a pointer (iterator) to the current book.
Post Increment Operator(i++):
Give me the book you're currently pointing at, then move to the next book.

To do this:
You photocopy the current book's page (make a copy).
You move to the next book.
You hand me the copy (the page before moving).
üì¶ Extra step: You had to make a copy.

Pre Increment Operator(++i ):
First move to the next book, then give me that book.

You just walk to the next book.
You give me the book you're now pointing to.
‚úÖ No need to copy anything.

Why we need copy ?
i++ needs a copy to return the original value before incrementing.
Whereas ++i does not need a copy because it returns the new value after incrementing.

Real-Life Analogy: Elevator Button Example
Imagine you're on floor 5, and you press a button to go up 1 floor. But someone asks:
‚ÄúTell me which floor you were on before you pressed the button.‚Äù
You can't just point to the elevator ‚Äî it's already moved. You'd need to write down your floor (make a copy) before moving, so the other person has the correct info.

// Post-increment
MyType MyType::operator++(int) {
    MyType temp = *this;  // make copy
    ++(*this);            // pre-increment actual value
    return temp;          // return original
}
// Pre-increment
MyType& MyType::operator++() {
    // increment actual value
    // no need to make a copy
    return *this;  // return reference to updated object
}

In low-level performance-critical code, you might prefer pre-increment (++i) because it avoids the overhead of copying.

10) Structure:
In C++, a structure (or struct) is a user-defined data type that allows you to group variables of different types under a single name. These variables, known as members, can be of different types

Feature	                                struct	class
Default access modifier	                public	private
Supports member functions	            ‚úÖ Yes	‚úÖ Yes  
Supports inheritance	                ‚úÖ Yes	‚úÖ Yes
Supports constructors/destructors	    ‚úÖ Yes	‚úÖ Yes

11) Enumerator: 
An enum (short for enumeration) is a user-defined type in C++ that consists of a set of named integral constants.
It improves code readability and makes programs easier to maintain by using meaningful names instead of raw numbers.

enum class for type safety
Avoids name conflicts (no Male/Female pollution in global namespace)
Safer comparisons (gender == Gender::Male)

12) Call by value vs Call by reference: 
In call by value, a copy of the variable is passed ‚Äî changes don't affect the original.
Use call by value when the function just reads or logs data.

In call by reference, a reference (alias) is passed ‚Äî so changes directly affect the original variable.(an alias for the original variable.)
Use call by reference when the function modifies the input ‚Äî like sorting, updating, or swapping.

Use call by value when you don't want the original data modified, and call by reference when you do.

13) Entry Controlled Loop  - while
    Exit Controlled Loop   - do {..}while(condition) 
    Count Controlled Loop  - for
    Conditional Statement  - if(condition){}, if{} else{}, if {} else if ()
    
Use do-while when the task must happen at least once, like menus or user input validation.
Use while when the condition must be true first, like checking a file is open before reading.

14)
| Term                 | Meaning                                                                                     |
| -------------------- | ------------------------------------------------------------------------------------------- |
| **Dangling Pointer** | A pointer pointing to memory that has already been **freed or deleted**.                    |
| **Void Pointer**     | A **generic pointer** that can point to any data type (but can't be dereferenced directly). |
| **Wild Pointer**     | A pointer that has been declared but **not initialized** (points to random memory).         |

16) const int& getValue() const;
In C++, `const int& getValue() const;` is a function declaration that indicates the following:
1. **Return Type**: The function returns a reference to a constant integer (`const int&`). This means the function will return a reference to an integer that cannot be modified.
Eg: object.getValue() = 10; // Error: Cannot modify a const reference

2. const after the function name (getValue() const)
The function is a **const member function**. This means the function does not modify any member variables of the class it belongs to.
It means the function:
Cannot modify any non-mutable members of the class.
Can be called on const objects.

17)namespace:
In C++, a namespace is a declarative region that provides a scope to the identifiers (variables, functions, classes, etc.) inside it so they don't conflict with names in other parts of the program.
namespace is in default public scope, meaning that all members of a namespace are accessible without any special access control.

18) using:
1) Using Directive ‚Äì Import all names from a namespace. Eg: `using namespace std;`
This allows you to use names from the `std` namespace without prefixing them with `std::`.
2) Using Declaration ‚Äì Import a specific name from a namespace Eg: `using std::cout;`
3) Using Type Alias ‚Äì Create a shorthand for a namespace or type 
Eg: using int_list = std::vector<int>;
This allows you to refer to `std::vector<int>` simply as `int_list`.

4) Using in Inheritance ‚Äì Expose base class members
Eg: `using BaseClass::memberFunctionwithSameFunctionName;`
When a derived class defines a function with the same name as a function in the base class (regardless of its signature), it hides all base class functions with that same name ‚Äî regardless of parameters.

Note:
In C++, when a derived class defines a function with the same name as a base class function, the base class version gets hidden, even if the signatures are different.
So this helps you:
Bring the base class version into the derived class scope.
Avoid function hiding

5) Using in Templates - Specify template parameters
Eg: `template<typename T> using vec = std::vector<T>;`
This allows you to create a shorthand for `std::vector<T>` as `vec<T>`, making your code cleaner and easier to read.

18)Template:
A template is a blue print for creating a generic class or function that can work with any data type. 
Templates are the foundation of generic programming, which involves to write a code in a way that is independent of any particular data type.

In C++, typename is a keyword used in templates to indicate that a type, will be provided later when the template is instantiated
Think of typename as
‚ÄúI am telling the compiler this symbol is going to represent a type.‚Äù

typename T 
T is a placeholder type.
Placeholder means it will be replaced with an actual type when the template is instantiated or during compilation

No extra memory or runtime cost ‚Äî all done at compile time.
No code is created for unused template types.

The compiler ensures that each template instance is generated only once - subsequent use of the same type will refer to the same instance

class vs typename in Template Parameters
In template parameters, both `class` and `typename` can be used interchangeably to define type parameters. There is no functional difference between the two in this context.
typename has an additional role when you're dealing with dependent names (like nested types inside template classes).
1)Referring to a Nested Type in a Template
A nested type is a type (like a class, struct, enum, or typedef) that is defined inside another class or struct.

Why do we need typename here?
Because Container is a template parameter, and Container::value_type is a dependent name ‚Äî the compiler can't know at this point whether value_type is a type or something else. You must clarify with typename.

typename Containe::value x = 5;

STL Containers Provide value_type
All standard library containers (like std::vector, std::list, std::set, etc.) define a member type called value_type.

Internally, it's something like:
template <typename T>
class vector {
public:
    using value_type = T;  // This is a type alias, not a keyword
};

1) Function Template:
A function template allows you to create a function that can operate on different data types without rewriting the function for each type.

2) Class Template:
A class template allows you to define a class that can work with any data type, making it reusable and flexible.

3) Template Specialization:
Template specialization allows you to define a specific implementation of a template for a particular data type or set of types. This is useful when you need different behavior for certain types while still using the generic template for others.

Syntax:
template <>
class ClassName<SpecializedType> {
    // Specialized implementation
};

Eg:
#include <iostream>
#include <string>
#include <vector>

// Template class definition
template <typename T>
class Printer {
public:
    void print(const T& data) {
        std::cout << "Generic print: " << data << std::endl;
    }
};

// Template class specialization for `std::string`
template <>
class Printer<std::string> {
public:
    void print(const std::string& data) {
        std::cout << "Specialized print for string: " << data << std::endl;
    }
};

// Template function definition
template <typename T>
void print_value(const T& value) {
    std::cout << "Generic print_value: " << value << std::endl;
}

// Template function specialization for `int`
template <>
void print_value<int>(const int& value) {
    std::cout << "Specialized print_value for int: " << value << std::endl;
}

int main() {
    // Using the generic Printer class
    Printer<int> intPrinter; // Generic version
    intPrinter.print(42);

    Printer<double> doublePrinter;
    doublePrinter.print(3.14);

    Printer<std::string> stringPrinter; 
    stringPrinter.print("Hello, world!");

    // Using the generic template function
    print_value(100);  // Calls the specialized version for int
    print_value(3.1415);  // Calls the generic version for double
    print_value("Hello, template!");  // Calls the generic version for string

    return 0;
}

19) std::optional:
`std::optional` is a feature in C++ that represents an optional value, meaning it can either contain a value or be empty (no value). It is part of the C++17 standard library and is used to handle cases where a value may or may not be present without resorting to pointers or special sentinel values.
It is useful when you want to indicate that a variable may not have a value, such as when a function might fail to produce a result or when a value is not applicable.
It is a safer alternative to using raw pointers or null values, as it explicitly indicates the possibility of absence.

Eg:
std::optional<int> maybeValue;  
if (maybeValue.has_value()) {
    std::cout << "Value is: " << *maybeValue << std::endl;
} else {
    std::cout << "No value present." << std::endl;
}

Syntax :
optional<T> can be empty or hold a value.
.has_value() ‚Üí checks if value exists.
.value() ‚Üí gets the value (throws if empty).
.value_or(default) ‚Üí safe way to get a value or fallback. Eg: .value_or("default value").
.reset() ‚Üí clears the optional (makes it empty).

It provides a way to express the absence of a value in a type-safe manner, avoiding issues like null pointer dereferencing.

21) override:
The `override` keyword is used in C++ to indicate that a virtual function in a derived class is intended to override a virtual function in the base class. It helps catch errors at compile time if the function does not actually override any base class function.
It ensures that the function signature matches the base class function exactly, preventing accidental mistakes like typos or mismatched parameters.

22) Why Does the Copy Constructor Take a Reference:
In C++, the copy constructor is responsible for creating a new object as a copy of an existing one. If the copy constructor were to take its argument by value, it would require making a copy of the object in order to pass it ‚Äî but to make that copy, the compiler would need to call the copy constructor again.

This creates an infinite recursive loop, where each call to the copy constructor requires another copy, which requires another constructor call, and so on. Eventually, this would lead to a stack overflow or a compiler error.

To avoid this, the copy constructor takes its parameter by reference ‚Äî specifically, const MyClass&. This allows the function to access the original object directly, without needing to copy it first, and ensures the original isn't accidentally modified during the copying process.

23) Deep Copy vs Shallow Copy:
A memory leak in C++ (or any language with manual memory management) happens when your program allocates memory but never frees it, causing that memory to be unusable and permanently reserved until the program ends.

A shallow copy copies the values of member variables as they are, including pointers.
If the object has a pointer to dynamically allocated memory, both the original and the copy will point to the same memory location. This can lead to unintended side effects like double deletion.

A deep copy creates a new copy of the dynamically allocated memory. It allocates separate memory and copies the actual data, so the copied object is independent of the original.

24)

25) double vs float:
| Feature            | float                     | double                    |
| ------------------ | ------------------------- | ------------------------- |  
| Size               | 4 bytes                   | 8 bytes                   |
| Precision          | 7 decimal digits          | 15-16 decimal digits      |
| Range              | ~1.2E-38 to 3.4E+38       | ~2.2E-308 to 1.7E+308     |
| Memory Usage       | Less memory               | More memory               |
| Performance        | Generally faster          | Generally slower          |
| Use Cases          | Graphics, games, simple calculations | Scientific computing, financial applications |    
| Default in C++     | No                        | Yes                       |

Due to lower precision, float may round or truncate values that a double can hold exactly.

26) typedef vs using:
typedef is the traditional way to create type aliases in C and C++.
using was introduced in C++11 and provides a cleaner, more powerful way to define aliases ‚Äî especially for template types.

Eg: 
// Using typedef (old style)
typedef void (*Callback)(int, double);

Callback fp = myFunction; // Much cleaner

// Using 'using' (modern and clear)
using Callback = void(*)(int, double);

// Only possible with 'using'
template<typename T>
using Vec = std::vector<T>;
    
Vec<int> v; // Same as std::vector<int>

26) size_t vs unsigned int:
`size_t` is an unsigned integer type used to represent the size of objects in memory.
Defined in the `<cstddef>` header, it is the result of the `sizeof` operator and is guaranteed to be large enough to hold the size of any object.
It is platform-dependent, meaning its size can vary based on the architecture (32-bit vs 64-bit).

unsigned int is usually always 32 bits, even on 64-bit systems. That means using unsigned int can truncate or overflow when dealing with large memory sizes.

Eg: 
size_t len = sizeof(huge_array);  // ‚úÖ Correct
unsigned int len = sizeof(huge_array);  // ‚ùå Risk of overflow

27) std::npos:
`std::npos` is a constant in the C++ Standard Library that represents the largest possible value for a size type, typically used to indicate "not found" in string and container operations.
It is defined in the `<string>` header and is used with functions like `std::string::find()` to indicate that a substring was not found.

Eg: 
std::string text = "hello";
size_t pos = text.find("x");  // "x" is not in the string

if (pos == std::string::npos) {
    std::cout << "Not found!\n";
}

pos will be set to -1 as there is no "x" in the string.
As size_t is an unsigned tpe, it wraps around to the maximum value that strings are never that long in real programs,so it's perfect for that.

Wrap around means going beyond the max or below 0 in unsigned types, and the value loops around like a clock.

28) Rule of Three:
The Rule of Three in C++ states that if a class manages resources (like dynamic memory), you should explicitly define three special member functions:
1. **Destructor**: Cleans up resources when the object goes out of scope or is deleted.
2. **Copy Constructor**: Creates a new object as a copy of an existing one, ensuring proper resource management.
3. **Copy Assignment Operator**: Assigns one object to another, ensuring resources are managed correctly during assignment.
to avoid shallow copy issues
If you define any of these, you should define all three to ensure proper resource management and avoid memory leaks or undefined behavior.

29) Rule of Five:

In C++, move semantics allow you to transfer ownership of resources (like memory, file handles, etc.) from one object to another without copying the resource. This is done using rvalue references (T&&), usually in a move constructor or move assignment operator.

Lvalue (Locator Value) vs Rvalue (Read Value / Temporary):
In C++, lvalues refer to objects that have a name and can be modified ‚Äî they exist in a specific memory location. Rvalues are temporary values that don‚Äôt persist ‚Äî like literals or the result of expressions.

rvalues ‚Äî temporary results of expressions, don't have a name

An lvalue reference (T&) binds to lvalues, while an rvalue reference (T&&) is used to bind to rvalues, enabling move semantics, which help optimize performance by avoiding deep copies of temporary objects.

std::move(b) --> It's just a cast. Converts lvalue b to rvalue reference so that the move constructor or move assignment operator can be called, transferring ownership of resources instead of copying them.
Under the hood, It returns static_cast<MyClass&&>

The Rule of Five in C++ extends the Rule of Three to include move semantics, which were introduced in C++11. It states that if a class manages resources, you should define five special member functions:
1. **Destructor**: Cleans up resources when the object goes out of scope or is deleted.
2. **Copy Constructor**: Creates a new object as a copy of an existing one, ensuring proper resource management.
3. **Copy Assignment Operator**: Assigns one object to another, ensuring resources are managed correctly during assignment.
4. **Move Constructor**: Transfers ownership of resources from a temporary object(rvalue) to a new object, avoiding deep copies and improving performance.
5. **Move Assignment Operator**: Transfers ownership of resources from a temporary object to an existing object, allowing efficient resource management during assignment.
This rule is important for classes that manage dynamic memory or other resources, as it ensures that both copy and move operations are handled correctly to avoid memory leaks, dangling pointers, or undefined behavior.

30) Temporary Objects in C++:
Temporary objects in C++ are short-lived objects created during expression evaluation, such as when passing arguments to functions or returning values from functions. They are created by the compiler to hold intermediate results and are destroyed at the end of the full expression in which they were created.
Temporary objects are created in the following scenarios:
1. When a function returns an object by value.
2. When a temporary object is created as part of an expression, such as in arithmetic operations or function calls.
3. When a temporary object is created to hold the result of a type conversion.
Temporary objects are typically created on the stack, and their lifetime is limited to the full expression in which they are created. They are automatically destroyed when they go out of scope, which helps manage memory efficiently.

31) Copy Elision:
Copy elision is an optimization where the compiler eliminates unnecessary copy or move operations, especially when returning or passing objects by value.
It avoids creating a temporary object and then copying/moving it ‚Äî instead, it constructs the object directly in its final place.
1)Return Value Optimization (RVO): RVO is a compiler optimization where a temporary object created as a function return value is constructed directly in the caller's memory, avoiding a copy or move constructor.
2)Named Return Value Optimization (NRVO): Similar to RVO, but applies when the returned object is named (not a temporary). The compiler can elide the move/copy by constructing the object directly in the caller's memory.
3)Temporary Object Elimination: When a temporary object is assigned or returned, the compiler can eliminate the intermediate temporary, constructing the final object directly in its destination

32) Inline Functions:
If a function is declared as inline, the complier places a copy of code of that function directly at the point of the call at compile time rather than performing a traditional function call(Control is transferred to the function, and then back to the caller).
No function call overhead (no pushing to stack, return address, etc.).

inline forces inlining	‚ùå No ‚Äî it's only a suggestion to the compiler

When to use inline functions:
1. Small functions: Functions that are small and frequently called, like getters or setters.
2. When you're defining functions in header files: Inline functions are often defined in header files to avoid multiple definitions errors.
Tells the compiler:
It's okay if this function is defined in multiple places ‚Äî treat them as the same(one definition).
Note:
Too much inlining can cause code bloat, which may hurt performance or increase binary size.
Code bloat means your binary (executable) becomes unnecessarily large due to repeated inlined code
The compiler processes more code during optimization -  Longer compile times
Eg:  multiply(i, i+1) in for loop

32) Inline Functions vs Macros:
Inline functions and macros are both used to replace code at compile time, but they have different characteristics
| Feature                | Inline Functions                          | Macros                                      |
| ---------------------- | ----------------------------------------- | ------------------------------------------- |
| Type Safety            | Yes (type-checked)                        | No (no type checking)                       |
| Scope                  | Scoped (local to the function or file)    | Global (visible everywhere)                 |
| Debugging              | Easier to debug (line numbers preserved)  | Harder to debug (no line numbers)           |
| Evaluation             | Evaluated once per call                   | Evaluated every time the macro is used      |
| Functionality          | Can be overloaded, templated              | No overloading, no templates                |

33) static keyword:
The `static` keyword in C++ has different meanings depending on where it is used:
1. **Static Local Variables**: When used inside a function, it declares a variable that retains its value between function calls.
2. **Static Global Variables**: When used outside any function, it limits the variable's scope to the file in which it is declared and  retains its value throughout the program's lifetime.
3. **Static Class Members**: When used in a class, it declares a member that is shared among all instances of the class, meaning it belongs to the class itself rather than any specific object.
4. **Static Member Functions**: A static member function belongs to the class itself, not to any individual object.
It can be called without creating an object, and it does not have access to this pointer.

Definition:
It is a member(variable or method) that is associated with the class rather than any specific instance of the class.
It is shared among all instances of the class, and it is initialized only once, at the start of the program. You can access it using the class name, like `ClassName::staticMember`.

Note: 
- Static variables are initialized only once, at the start of the program, and retain their value respective to the scope they are defined in.
- Static member variables must be defined outside the class definition if they are to be used, as they are not automatically instantiated for each object.
    - Class declaration is just a blueprint, not the actual code that creates memory.
    - Static member variables are stored in static/global memory segment, not in the stack or object memory.
    - the compiler needs an explicit definition outside the class to allocate actual memory for them.
- Static member functions can access static member variables because they belong to the class, not to any specific object.
- static int count = 0; // ‚ùå Not allowed (definition) inside class 
   - If you define it inside the class, then every .cpp file that includes the header will get its own copy of that static variable.
   - This causes a "multiple definition" error when the program is linked.   

34) 
| Feature                   | **Reference (`&`)**                            | **Pointer (`*`)**                            |
| ------------------------- | ---------------------------------------------  | -------------------------------------------- |
| **Definition**            | An alias for another variable                  | Holds the memory address of another variable |
| **Syntax**                | `int& ref = x;`                                | `int* ptr = &x;`                             |
| **Null value?**           | ‚ùå No (must refer to something valid)          | ‚úÖ Yes (can be `nullptr`)                   |
| **Reassignment?**         | ‚ùå No (once set, always refers to same object) | ‚úÖ Yes (can point to different objects)     |
| **Dereferencing**         | Not needed ‚Äî it acts like the original         | ‚úÖ Yes: `*ptr` to access value               |
| **Memory address access** | `&ref` gives the address of original           | `ptr` holds the address itself               |
| **Use in functions**      | Pass-by-reference (like alias)                 | Pass-by-pointer (manual dereferencing)       |

35) Types of "relationships" between classes(objects) 
1. Association - General Relationship
Association is a generic relationship where one class uses or is connected to another. There's no ownership.
Both objects can exist independently of each other.

‚ÄúUses-a‚Äù or ‚Äúknows-a‚Äù relationship
No ownership
Lifespan is independent

Eg: 
A teacher and a student - a teacher can teach many students, and a student can be taught by many teachers.

2. Aggregation - Whole-Part, Weak Ownership
Aggregation is a special type of association where one class contains a reference to another, but the contained object can live independently of the container.

‚ÄúHas-a‚Äù relationship
Weak ownership
Lifespan is independent
Implemented using pointers or references

Eg:
A Library has many Books, but a Book can exist without the Library
If the Library object is destroyed, the Book objects still exist.

A Team has Players, but Players can exist without the Team

3. Composition - Whole-Part, Strong Ownership :
Composition is a strong form of aggregation where one class owns another, and the lifecycle of the owned object is controlled by the owner.

Owns-a‚Äù relationship
Strong ownership
Lifespan is dependent (child destroyed with parent)
Implemented as member objects (by value)

Eg:
A House has Rooms, and if the house is destroyed, so are the rooms
A Human has a Heart, and the heart can't exist without the human

36) Time Complexity & Space Complexity:
Time Complexity:
The relation describing how run time grows as the input size increases.
It is the measure of how the running time of an algorithm grows with respect to the input size n, not the actual clock time.
It is usually expressed using Big O notation, which describes the upper bound of the algorithm's running time in the worst case.

Space Complexity :
It is the measure of how much memory an algorithm needs as the input size n increases.

Time complexity = how fast it grows with input.
Space complexity = how much memory it uses with input.

37) Typecasting in C++:
It is the process of converting a variable from one data type to another. C++ supports implicit (automatic) and explicit (manual) typecasting.

1. **Static Cast (`static_cast<type>(expression)`)**:
   - Used for compile-time type conversions.
   - Safe for conversions between related types (e.g., int to float, base class to derived class).
   - Cannot cast away `const` or `volatile` qualifiers.
   - Example: `int i = static_cast<int>(3.14); // Converts double to int`
2. **Dynamic Cast (`dynamic_cast<type>(expression)`)**:
   - Used for safe downcasting in class hierarchies (from base to derived).
   - Requires at least one virtual function in the base class because it relies on runtime type information (RTTI).
   - Returns `nullptr` if the cast fails (for pointers) or throws `std::bad_cast` (for references).
   - Example: 
    class Entity {
        public:
            virtual ~Entity() {}  // Just destructor is enough  
    };
    vector<Entity*> entities = getAllEntities();
    for (auto e : entities) {
        if (Player* p = dynamic_cast<Player*>(e)) {
            p->attack();  // Safe call for Player
        }
        else if (Enemy* en = dynamic_cast<Enemy*>(e)) {
            en->flee();   // Safe call for Enemy
        }
    }
3. **Const Cast (`const_cast<type>(expression)`)**:
   - Used to add or remove `const` or `volatile` qualifiers.
   Note: 
   If the original object was const, don‚Äôt modify it after const_cast. If it was non-const, removing const is safe.
   - Should be used with caution, as modifying a `const` object leads to undefined behavior.
   - If an object is declared const, the compiler and runtime may place it in read-only memory, so writing to it could crash your program or corrupt data.
   - Example: 
    1) int x = 10;
    const int* p = &x;

    // Remove constness
    int* q = const_cast<int*>(p);
    *q = 20;  // OK, x is modified safely

    2) const int y = 10;
    const int* p = &y;

    // Remove constness
    int* q = const_cast<int*>(p);
    *q = 20;  // Undefined behavior! y was originally const

4. **Reinterpret Cast (`reinterpret_cast<type>(expression)`)**:
   - Used for low-level reinterpreting of bit patterns.
   - Can cast between unrelated types (e.g., pointer to int, int to pointer).
   - Should be used sparingly, as it can lead to non-portable and unsafe code.
   - Example: `int* p = reinterpret_cast<int*>(0x12345678); // Converts int to pointer

38) OOPS :
1) Object-Oriented_Programming(OOP):
OOP's a programming paradigm that implements the concept of "objects", which can contain data and code to manipulate that data.

2) Object: 
Objects are real-world entities that encapsulate both state (attributes) and behavior (methods/functions).
An object is an instance of a class that contains data (attributes) and functions (methods) to operate on that data.
Note:
When you create a real object from that blueprint(class), that object is called an instance of the class
Each object has its own copy of non-static data members.
Objects can use member functions defined in the class.

3) Class:
A class is a blueprint or template for creating objects.
It does not occupy memory itself. Memory is allocated only when an object is created. class will occupy memory only when an object of that class is instantiated. If you check sizeof(className), it will give you the size of an object of that class, not the class itself.

Memory Visualization:
When you define a class with functions, the code of the function is **stored once in memory**, not inside each object.
Objects only store data members.

Functions are shared by all objects of the class.
If functions were stored in each object, memory usage would explode when creating multiple objects.

Static data members --> Stored once, shared by all objects
Static member functions --> Stored once, callable without object 

Note:
Static Member Functions Can Be Called Without an Object
Static member functions belong to the class itself, not to any specific object
So, you can call a static function directly using the class name, without creating any object

sizeof(class) = size of an object of that class
Includes all non-static members + padding
Does not include member functions or static members they are included in shared memory i.e., text segment

4) Constructor:
A constructor is a special member function of a class that is automatically called when an object of that class is created.
It is used to initialize the object's data members if needed to make sure the object starts in a valid state.
It does not have a return type because its purpose is to initialize the object (that has already been created in memory), not to return a value. It won't return anything even void. Returning it would be redundant, and unsafe in many cases because the object is already created.

It's returned automatically by the compiler/runtime when you use new or create it on the stack.

Types of Constructors:
1. Default Constructor: A constructor that takes no parameters or has default values for all parameters used to create an object with default values.
2. Parameterized Constructor: A constructor that takes parameters to initialize an object with specific values at the time of creation.
3. Copy Constructor: A constructor that creates a new object as a copy of an existing object failing to do so can lead to shallow copy issues.
Deep Copy vs Shallow Copy:
A memory leak in C++ (or any language with manual memory management) happens when your program allocates memory but never frees it, causing that memory to be unusable and permanently reserved until the program ends.

A shallow copy copies the values of member variables as they are, including pointers.
If the object has a pointer to dynamically allocated memory, both the original and the copy will point to the same memory location. This can lead to unintended side effects like double deletion.

    A deep copy creates a new copy of the dynamically allocated memory. It allocates separate memory and copies the actual data, so the copied object is independent of the original.
    Syntax:
    ClassName(const ClassName& other) {
    // Copy data members from 'other' to 'this'
    this->data = other.data; // Deep copy if needed
}

Why Does the Copy Constructor Take a Reference:
In C++, the copy constructor is responsible for creating a new object as a copy of an existing one. If the copy constructor were to take its argument by value, it would require making a copy of the object in order to pass it ‚Äî but to make that copy, the compiler would need to call the copy constructor again.

This creates an infinite recursive loop, where each call to the copy constructor requires another copy, which requires another constructor call, and so on. Eventually, this would lead to a stack overflow or a compiler error.

To avoid this, the copy constructor takes its parameter by reference ‚Äî specifically, const MyClass&. This allows the function to access the original object directly, without needing to copy it first, and ensures the original isn't accidentally modified during the copying process.

4. Move Constructor:
A move constructor is a special constructor that transfers ownership of resources from a temporary (rvalue) object to a new object, avoiding deep copies and thus improving performance.

When you copy an object (using the copy constructor), a deep copy is made.
That means ‚Äî the entire resource (like a big array or vector) is duplicated.

Instead of copying the data, the move constructor transfers the resource ownership ‚Äî i.e., it just moves the pointer to the new object!

A move constructor is called when a temporary object (rvalue) is used to initialize another object.
rvalue (read value) T&& :
object without a name (temporary object, e.g., returned from a function, std::move() result or literal (like 42, 3.14)). 
lvalue (locator value) T& :
object with a name and can be modified (like a variable). they exist in a specific memory location

Commonly triggered when:
Returning a local object from a function.
Initializing with a temporary.
Using std::move().

Syntax:
ClassName obj1;               // Calls default constructor
ClassName obj2(10,20);        // Calls parameterized constructor
ClassName obj3 = obj2;        // Calls copy constructor

ClassName obj2 = std::move(obj1); // Calls move constructor 
or
ClassName obj3 = ClassName(); // Temporary object, calls move constructor
ClassName(ClassName&& other) noexcept {
    // Transfer ownership of resources from 'other' to 'this'
    this->data = other.data; // Shallow copy of pointer
    other.data = nullptr;    // Leave 'other' in a safe state
}

Here ClassName() creates a temporary object. It exists only until the end of the full expression and has no variable name.You can't assign to it ClassName() = obj1; // ‚ùå Error

5. Explicit Constructor:
An explicit constructor is a constructor that prevents implicit conversions i.e., stops the compiler from automatically converting one type to another when passing or assigning values to objects of that class. Forcing safe and intentional conversions only.
The compiler can implicitly convert a matching value (like int) into an object by calling that constructor behind the scenes.

It is declared using the `explicit` keyword before the constructor definition.  
Explicit is mainly used for single-argument constructors to avoid unintended implicit conversions. For multiple arguments, implicit conversions are unlikely because the compiler cannot map multiple parameters from a single value. 

It can lead to undefined behavior if the class manages resources and the implicit conversion results in multiple objects sharing the same resource.
Eg:
class Meter {
    int value;
public:
    Meter(int v) : value(v) {}
    //explict Meter(int v) : value(v) {}
    Meter operator+(const Meter& m) { return Meter(value + m.value); }
    void show() { std::cout << value << " m\n"; }
};

int main() {
    Meter m1(5);
    Meter m2 = m1 + 10;  // ‚ùå Implicitly converts 10 -> Meter(10)
    Meter m3 = m1 + Meter(15); // ‚úÖ Explicitly creates Meter object
    m2.show();
}

Constructor chaining:
Constructor chaining is the process where one constructor calls another constructor in the same class or in the base class to ensure proper initialization of an object.
It helps avoid code duplication and ensures that all necessary initialization steps are performed.
It can occur in two ways:
1. Within the same class (using delegating constructors).
2. Between base and derived classes (base class constructor called before derived class constructor).

6. Delegating Constructor:
A delegating constructor is a constructor that calls another constructor of the same class to perform part of the initialization.
It helps avoid code duplication by reusing existing constructor logic within the same class.

Use cases:
When multiple constructors share common initialization code. 

Eg:
class Box {
    int length, breadth, height;
public:
    // Main constructor (parameterized)
    Box(int l, int b, int h) : length(l), breadth(b), height(h) {
        cout << "Box(int,int,int) called: "
             << "L=" << length << ", B=" << breadth << ", H=" << height << endl;
    }

    // Delegating constructor (calls main constructor)
    Box() : Box(1, 1, 1) {   // default box of size 1x1x1
        cout << "Box() called (delegates to Box(int,int,int))\n";
    }

    // Another delegating constructor
    Box(int size) : Box(size, size, size) {  // cube box
        cout << "Box(int) called (delegates to Box(int,int,int))\n";
    }
};

Why constructors cannot be static:
Constructors cannot be static in C++ because:
A constructor is meant to initialize an instance of a class, and static members belong to the class itself, not to any specific instance.
Static functions cannot access instance members directly, as they do not have a `this` pointer.

Why constructors does not return a value:
Constructors do not return a value because their purpose is to initialize an object, not to produce a value like a regular function. They are called automatically when an object is created, and they set up the initial state of that object.

You don‚Äôt need to call it manually like a regular function.

Initialize list:
An initializer list is a part of the constructor syntax that allows you to initialize base classes and member variables directly before the constructor body runs.

Number of operations will be reduced:
If we don't use an initializer list, the member variables are first default-initialized and then assigned, which leads to unnecessary extra operations ‚Äî the initializer list avoids this by constructing the members directly with the desired value. 

In C++, the initializer list is used because:
It runs before the constructor body
It's the only place where you can initialize base classes and member variables
It ensures the base class is fully constructed before any derived-class-specific logic runs

Fully constructed means the object's memory is allocated, all its members are initialized, and its constructor has executed, making it ready for safe use

Eg: 
Example1: //Without initializer list
Default constructor --> By default, it calls the default constructor (if available) to ensure the member exists in a valid state. Valid state means the member has been allocated in memory and properly initialized and is ready for use.
Assignment operator

Example2: //With initializer list
Parameterized constructor (Copy constructor) --> We are telling the compiler to directly initialize the member with the provided value during construction.

Note:
Initializer lists don't allow loops or multi-step logic.
Only simple one-line expressions are allowed there.

| Type                               | Must Use Init List?  | Why                                    |
| ---------------------------------- | ---------------------| ---------------------------------------|
| `const` members                    | ‚úÖ Yes               | Cannot be assigned after construction  |
| `T&` references                    | ‚úÖ Yes               | Must be bound immediately              |
| Base class with no default ctor    | ‚úÖ Yes               | Must call constructor in init list     |
| Member object with no default ctor | ‚úÖ Yes               | Needs explicit initialization          |

Members cannot be initialized in the constructor body because by that time they already exist in memory. Const and reference members must be initialized in the initializer list since they cannot be assigned later.
1) const members:
   - Const members must be initialized in the initializer list because their value is fixed at object creation and cannot be assigned in the constructor body.
   - Example: `const int x;` must be initialized like this: `MyClass(int val) : x(val) {}`
2) Reference members:
   - Must be initialized in the initializer list because references must be bound to an object at the moment it's created ‚Äî once set, it always refers to the same object.
3) Base class with no default constructor:
   - If a base class does not have a default constructor, you must call its constructor in the initializer list of the derived class.

   When creating a derived object, C++ constructs the base part first. If the base class has no default constructor ‚Äî and you've defined a user-defined constructor, the compiler assumes you're handling all initialization yourself ‚Äî so it won't generate a default constructor automatically. Therefore, the derived class must explicitly call a specific base constructor in its initializer list, because base and member initialization happen before the constructor body runs to ensure that all parts of the object are in a valid, usable state.
    - Example: `Derived(int val) : Base(val) {}`
4) Member objects with no default constructor:
   - If a member object does not have a default constructor, you must initialize it in the initializer list because it cannot be default-constructed. Since you defined a user-defined constructor, the compiler assumes you're handling all initialization yourself. Therefore, you must explicitly call a specific member constructor in its initializer list to ensure it is properly constructed before the constructor body runs.
   - Example: `MyClass(int val) : memberObj(val) {}`

5) Destructor:
A destructor is a special member function of a class that is automatically called when an object of that class goes out of scope or is explicitly deleted.
It doesn't have no parameters, and no return type.

When an object's lifetime ends, the compiler knows exactly how to destroy it ‚Äî there's no need for multiple destructors with parameters or overloads.

It is used to release resources ‚Äî memory, file handles, network connections, etc.

Types of Destructors:
1. Default Destructor: Automatically provided by the compiler if no destructor is defined. It performs default cleanup of member variables.
2. Custom Destructor: A user-defined destructor that performs specific cleanup tasks, such as releasing dynamically allocated memory or closing file handles.
3. Virtual Destructor: It is a destructor used to ensure proper cleanup of derived class objects when deleted through a base class pointer.
It guarantees that the derived class destructor is called first, followed by the base class destructor, preventing resource leaks in polymorphic scenarios.

Internally:
A virtual destructor uses the object's vptr to look up the vtable at runtime, ensuring the destructor of the actual derived object is called first, followed by the base destructor, enabling proper cleanup.
4. Pure Virtual Destructor: A pure virtual destructor is a destructor declared with the `= 0` syntax, making the class abstract. It forces derived classes to implement their own destructors while still providing a base destructor implementation.

When deleting a derived object through a base pointer, the destructor sequence is always:
Derived destructor (Derived destructor calls Base::~Base() automatically.)‚Üí Base destructor
Without a base destructor body, the program would have undefined behavior or linker errors.

If the base class is abstract, so the compiler doesn't know its layout or what resources it manages, and cannot generate a default destructor ‚Äî the programmer must provide one. Derived classes are concrete, so the compiler knows their layout and resources and can generate default destructors. Concrete means fully defined and instantiable

Syntax:
~ClassName() {
    // Cleanup code here
}

For virtual destructor:
virtual ~BaseClass() {
    // Base class cleanup
}

For pure virtual destructor:
virtual ~BaseClass() = 0; // Declaration
BaseClass::~BaseClass() {
    // Base class cleanup implementation
}

4) Abstraction:
Abstraction is the process of hiding the internal implementation details of a class or function and showing only the essential features to the user.

It focuses on what an object does, not how it does it.
Achieved using abstract classes and interface in C++.

What is an abstract class?
An abstract class is a class that cannot be instantiated on its own. It is designed to act as a base class and usually contains at least one pure virtual function.
It is used to provide a common interface for all derived classes.
Keypoints:
You cannot create objects of an abstract class.
You can create pointers or references to it.
Derived classes must override all pure virtual functions to become concrete

Can contain:
Pure virtual functions (must be overridden)
Normal member functions (optional implementation)
Data members

Key Points:
If a class has at least one pure virtual function, it becomes abstract.
Objects of abstract classes cannot be created (because they are incomplete.)
Accessed only through pointers or references to base class.
Can contain both implemented and unimplemented methods i.e., can have both normal and pure virtual functions.
You cannot create an object of an abstract class directly.

What is a pure virtual function?
A pure virtual function is a virtual function that does not have an implementation in the base class and forces derived classes to provide their own implementation of the function.
It is declared by assigning 0 in its declaration.Declaring at least one pure virtual function makes the class abstract.

What is a virtual function?
A virtual function is a member function in a base class that you expect to override in derived classes.
When a virtual function is called it depends upon the actual object type at runtime rateher than the declared type of pointer or reference at compile time.

Interface:
An interface is a class that has only pure virtual functions and no data members or implemented methods.

Keypoints:
All methods are pure virtual (no implementation) and no data members.
No constructors or destructors (since no objects can be created).
Used to define a contract that derived classes must follow.

5) Encapsulation:
Encapsulation is the process of wrapping data (variables) and functions (methods) together in a single unit, i.e., a class, and restricting direct access to some of the object‚Äôs components.

Key points:
Achieved using access specifiers: private, protected, public.
Protects data integrity.
Users can access data only through public methods (getters/setters methods)

Protected:
Members declared as protected are accessible inside the class and its derived classes, but not accessible outside the class hierarchy.

6) Inheritance:
It is a property by which one class (derived class) acquires the properties and behaviors of another class (base class).

| Type                            | Description                                                 | Example                                           |
| ------------------------------- | ----------------------------------------------------------- | ------------------------------------------------- |
| **1. Single Inheritance**       | When a class inherits from only one base class              | `A ‚ÜíB`                                           |
| **2. Multiple Inheritance**     | When a class inherits from more than one base class.        | `A, B ‚Üí C`                                        |
| **3. Multilevel Inheritance**   | When a class derived from another derived class             | `A ‚Üí B ‚Üí C`                                       |
| **4. Hierarchical Inheritance** | When multiple classes inherit from the same base class      | `A ‚Üí B, C, D`                                     |
| **5. Hybrid Inheritance**       | Combination of multiple types (e.g., multiple + multilevel) | Used in complex systems (e.g., `A‚ÜíB, A‚ÜíC, B,C‚ÜíD`) |


| Base class members    | Public inheritance   | Protected inheritance | Private inheritance |
| --------------------- | -------------------- | --------------------- | ------------------- |
| **public** members    | become **public**    | become **protected**  | become **private**  |
| **protected** members | become **protected** | become **protected**  | become **private**  |
| **private** members   | **not inherited**    | **not inherited**     | **not inherited**   |

| Concept         | Relationship Type | Lifetime Dependency | Ownership | Example                | Real-world Meaning                          |
| --------------- | ----------------- | ------------------- | --------- | ---------------------- | ------------------------------------------- |
| **Association** | Uses-A            | Independent         | No        | `Teacher-Student`      | Work together, no dependency                |
| **Aggregation** | Has-A (Weak)      | Independent         | Partial   | `Department-Professor` | Container uses others, but doesn‚Äôt own them |
| **Composition** | Has-A (Strong)    | Dependent           | Full      | `Car-Engine`           | Part cannot exist without whole             |

Association:
Association is a general relationship between two classes where both can exist independently.

Aggregation:
Aggregation is a special form of association where one class contains a reference to another class, but the contained object can exist independently of the container.

Composition:
Composition is a strong form of association where one class owns another class completely.
The lifetime of the contained object depends on the owner

Virtual Inheritance:

       A
      / \
     B   C
      \ /
       D

A  - Base class
B, C - Derived classes inheriting from A    
D - Derived class inheriting from both B and C

Diamond hierarchy (also known as the diamond problem) occurs when a class inherits from two classes that both inherit from a common base class.
It leads to potential issues, particularly when a method or attribute from the base class is inherited multiple times.

C++ uses virtual inheritance. It makes sure that the base class is only included once, no matter how many times it's inherited through the different paths in the hierarchy. This way, all derived classes share the same single instance of the base class, avoiding duplication.

The compiler adds a hidden pointer called vbptr in every class that virtually inherits a base class. This pointer points to something called the Virtual Base Table (vbtable).
All derived classes use this vbptr to access the shared base class. This ensures that there is only one instance of the base class, even though there are multiple paths to it.

The constructor of the most derived class is responsible for setting the final values of inherited members, with the last called constructor overriding any previous changes.

Different from vptr:
The vbptr is an internal pointer that only gets added to derived classes (i.e., classes like B, C, and D) that virtually inherit from a base class (A in this case).
B and C each have their own vbptr, but both of those vbptr pointers point to the same shared instance of A.

The vptr, on the other hand, is added to every class that has virtual functions, regardless of whether it uses virtual inheritance or not.

7) Polymorphism:

Polymorphism is the ability of a function or method to behave differently based on the object that it is acting upon.
There are two types of polymorphism in C++:
1. Compile-time polymorphism (Static polymorphism)
2. Run-time polymorphism (Dynamic polymorphism)

1) Compile-time :
The phase when the source code is translated into machine code (executable) by the compiler. Everything checked or decided before the program runs is compile-time.

2) Run-time :
The phase when the program is executing (running). Decisions made while the program is running, based on user input or other dynamic factors, are run-time.

1. Compile-time polymorphism:
Achieved using function overloading and operator overloading.
It allows multiple functions or operators to have the same name but behave differently based on the arguments passed to them.

a. Function Overloading:
This is when you define multiple functions with the same name but different parameters (either in number or type).
1. Order of Priority in Function Overloading:

When the compiler has to choose between multiple overloaded functions, it follows this order of priority:
1) Number of Parameters:
The compiler first checks the number of parameters passed to the function.
If the number of arguments in the call exactly matches one of the overloaded versions, that function is chosen.

2) Type of Parameters:
If there are multiple overloads with the same number of parameters, the compiler looks at the data types of the arguments.
It will select the function whose parameter types best match the types of the arguments you provided.
The order of preference (from best to least preferred) is:
Exact match (no conversion)
Promotion (e.g., char ‚Üí int, float ‚Üí double, short ‚Üí int) // Converts a smaller type to a larger one within the same category without loss of information
Standard conversion (e.g., int ‚Üí double, Derived* ‚Üí Base*) // Conversions defined by the language itself, but not just size promotion.
User-defined conversion (via constructors or operator T()) // Conversions defined by the constructor or conversion operator of a class.
Ellipsis (...) // Least preferred, used when no other match is found. 

3) Default Arguments:
If you don't provide a value for a parameter that has a default argument, the compiler will use the default value.
If there is ambiguity, the compiler will give priority to functions that do not require implicit conversions (i.e., exact matches are preferred over implicit type conversions).

Exact Match vs Implicit Conversion:
If no exact match exists, the compiler will try to convert types (implicit conversion) to match the function signature.
However, exact matches are always prioritized.

Default Arguments Are Always Assigned from Right to Left
You can't skip a parameter in the middle. Once you skip one, all the parameters to the right must also be skipped or will take default values.
In C++, the parameters in a function are ordered. The rightmost parameters (those at the end) are optional and can be skipped because of default arguments. The compiler can use the default values for any arguments that aren't provided.

b. Operator Overloading:
Operator overloading allows you to define custom behavior for operators (like +, -, *, etc.) when they are used with user-defined types (classes).

We cannot overload below operators because they have special meanings in C++:
1. Scope resolution operator (::)
2. Member access operator (.)
3. Ternary conditional operator (?:)
4. sizeof operator 

operator+ :x
creates a new temporary object (an rvalue) that doesn't persist after the expression ends.
Returning it by reference would refer to that destroyed temporary, causing undefined behavior.
Since you can't bind a non-const lvalue reference to an rvalue, the correct and safe approach is to return it by value.
In contrast, operator= :
modifies the current object (an lvalue), which already exists in memory.
Returning *this by lvalue reference is both valid and efficient, because it refers to the same persistent object and enables chained assignments like a = b = c without creating unnecessary temporary copies.

Why can't we bind non-const lvalue references to temporaries (rvalues)?
In C++, lvalue references (T&) are meant to refer to objects that have a persistent memory location (lvalues). Temporaries (rvalues) are short-lived objects that are created during expression evaluation and are destroyed at the end of the full expression, so binding a non-const lvalue reference to a temporary would lead to dangling references and undefined behavior.

2. Run-time polymorphism:
Achieved using virtual functions and inheritance.
It allows a function to behave differently based on the actual object type at runtime, rather than the type of the pointer or reference.

Virtual Functions:
A virtual function is a member function in a base class that you expect to override in derived classes. It allows for dynamic (runtime) polymorphism, meaning the function that gets called is determined by the type of the object being pointed to, not the type of the pointer itself.

a) vtable:  
When a class has virtual functions, the compiler creates a special table called the vtable (virtual table) for that class. It stores the addresses of the virtual functions for a class. It's like a list (table) of function pointers.
Created: By the compiler, during compile time.
Stored: As a static table in memory (one per class with virtual functions).
Used for: Runtime dispatch of virtual functions

b) vptr:
Each object of a class with virtual functions has a hidden pointer called vptr (virtual pointer).
It points to the vtable of the class that the object belongs to.
When: Automatically set up by the constructor, Used at runtime to resolve which function to call.
Created by the compiler when your class contains at least one virtual function.
vptr is declared at compile time, but it is set to point to the correct vtable at runtime when the object is created.

When you call a virtual function on an object, the compiler uses the vptr to look up the correct function in the vtable and calls it. This allows for dynamic dispatch, meaning the correct function is called based on the actual type of the object at runtime, not just the type of the pointer.

Why constructors cannot be virtual:
Constructors cannot be virtual in C++ because:
vptr is not fully set up when a constructor is called. (The vptr is initialized/set inside the constructor.)
When an object is being constructed, the complier set up the vptr to point to the class's vtable.
But that happens as part of the constructor ‚Äî it is not fully established before the constructor begins.

Why destructors can be virtual:
Destructors can be virtual in C++ because:
When a destructor is called, the vptr is already set up to point to the correct vtable for the derived class.
This allows the destructor to call the correct derived class destructor, ensuring proper cleanup of resources.
Like when you delete a base class pointer that points to a derived class object, the virtual destructor ensures that the derived class's destructor is called first, followed by the base class destructor.

Consequences of not calling the derived destructor first 
1. Resource leaks 
2. Undefined behavior --> If the derived class accesses data in its destructor that relies on the base  ‚Äî but the base was already destroyed leads to crash, segment faults.

39) Smart Pointers:
1) std::unique_ptr
2) std::shared_ptr
3) std::weak_ptr

1) std::unique_ptr:
A `std::unique_ptr` is a smart pointer in C++ that manages a dynamically allocated object and ensures that there is only one owner of that object at any given time. It automatically deletes the managed object when the `unique_ptr` goes out of scope, preventing memory leaks.

Usage:
#include <memory>       
std::unique_ptr<MyClass> ptr1(new MyClass()); // Create a unique_ptr
or
auto ptr1 = std::make_unique<MyClass>(); // Preferred way to create a unique_ptr

2) std::shared_ptr:
A `std::shared_ptr` is a smart pointer in C++ that allows multiple pointers to share ownership of a dynamically allocated object. It uses reference counting to keep track of how many `shared_ptr` instances point to the same object. When the last `shared_ptr` pointing to the object is destroyed or reset, the managed object is automatically deleted.

make_shared is preferred because:
1. Efficiency: Allocates memory for both the control block and the object in a single allocation, reducing overhead.
2. Exception Safety: Ensures that if an exception is thrown during object construction, no memory is leaked because the allocation of the control block and the object is atomic, so either both succeed or neither does.
auto sptr = std::make_shared<MyClass>(constructor_args);

Eg: 
void risky(std::shared_ptr<MyClass> p, int x);
risky(std::shared_ptr<MyClass>(new MyClass()), doSomething());

new MyClass() is executed first ‚Äî it allocates a raw pointer on the heap.
Then doSomething() is called to get the second argument (x).
If doSomething() throws an exception, the line is interrupted before the shared_ptr is constructed which handles the raw pointer.
As a result, the raw pointer returned by new MyClass() is never managed by any shared_ptr, causing a memory leak.

std::make_shared<MyClass>() wraps both the allocation and the shared_ptr creation inside one expression, so no raw pointer ever exists temporarily outside of a shared_ptr.
Even if doSomething() throws, everything is cleaned up automatically.

Exception not to use make_shared:
When you need a custom deleter for the managed object, you cannot use `std::make_shared` because it does not allow specifying a custom deleter. In such cases, you must create the `shared_ptr` using its constructor that accepts a raw pointer and a deleter function.

Control block:
The control block is a small structure that manages the reference count. 
It keeps track of how many `shared_ptr` instances and 'weak_ptr' instances point to the same object and ensures proper deletion when the last reference is gone.
Control block contains:
1. Strong reference count: Number of `shared_ptr` instances pointing to the object.
2. Weak reference count: Number of `weak_ptr` instances pointing to the object.
3. Deleter function: Function to delete the managed object when the last `shared_ptr` is destroyed.
4. Pointer to the managed object.

The control block remains alive as long as any weak_ptr exists, allowing weak pointers to safely check object validity or attempt to create a shared_ptr; without it, functions like weak_ptr.expired() or weak_ptr.lock() would access invalid memory once the object is destroyed.

weak_ptr.expired() ‚Üí checks strong_count inside the control block(i.e strong_count == 0) to see if the managed object has been deleted.
weak_ptr.lock() ‚Üí creates a new shared_ptr only if strong_count > 0, safely incrementing it.

You create a shared_ptr ‚Üí strong_count = 1, weak_count = 0
Copy a shared_ptr ‚Üí strong_count++
Destroy a shared_ptr ‚Üí strong_count--
When strong_count reaches 0 ‚Üí managed object is deleted
When you create a weak_ptr from a shared_ptr ‚Üí weak_count++
Destroy a weak_ptr ‚Üí weak_count--
When both strong_count and weak_count reach 0 ‚Üí control block is deleted

std::shared_ptr<MyClass> p1 = std::make_shared<MyClass>();

std::shared_ptr<MyClass> p2 = p1;
std::shared_ptr<MyClass> p3 = p2;
std::shared_ptr<MyClass> p4 = p3;
std::shared_ptr<MyClass> p5 = p1;

When will be managed object will be destroyed.
The managed object (MyClass instance) is deleted only when the last std::shared_ptr owning it is destroyed or reset, i.e. when reference count becomes 0.

They all go out of scope at the end of main().
The compiler destroys them in reverse order of creation (p5, then p4, then p3, then p2, then p1).
Each destruction decreases the reference count by 1.

If destruction happened in the same order as creation, later variables that depend on earlier ones could access already-destroyed objects, causing serious runtime bugs.

3) std::weak_ptr:
A `std::weak_ptr` is a smart pointer in C++ that provides a non-owning reference to an object managed by a `std::shared_ptr`. It allows you to observe or access the object without affecting its lifetime, preventing circular references that can lead to memory leaks.

Breaking circular references: In cases where two or more shared_ptrs refer to each other, using std::weak_ptr for one of the references prevents a memory leak.

Can be converted to shared_ptr: You can convert a std::weak_ptr to a std::shared_ptr by calling the lock() function. This creates a temporary shared_ptr if the object still exists, or returns an empty shared_ptr if the object has already been destroyed.

#include <memory>
std::shared_ptr<MyClass> sptr = std::make_shared<MyClass>();
std::weak_ptr<MyClass> wptr = sptr; // Create a weak_ptr from shared_ptr

if (auto lockedNode = wptr.lock()) {
    std::cout << "Node1 is still alive: " << lockedNode->data << std::endl;
} else {
    std::cout << "Node1 has been destroyed." << std::endl;
}


class A { public: shared_ptr<B> bptr; };
class B { public: shared_ptr<A> aptr; };

int main()
{
    auto a = make_shared<A>();
    auto b = make_shared<B>();

    a->bptr = b;
    b->aptr = a;

} // main ends

When main() ends (only shared_ptr version ‚Äî circular dependency case):
b goes out of scope ‚Üí shared_ptr<B> destructor runs ‚Üí B's strong count goes from 2 ‚Üí 1 (because A.bptr still holds one strong reference to B).
a goes out of scope ‚Üí shared_ptr<A> destructor runs ‚Üí A's strong count goes from 2 ‚Üí 1 (because B.aptr still holds one strong reference to A).
Now, when A is supposed to be destroyed, its strong count is not 0 ‚Äî because B.aptr still points to A. So A is not destroyed yet.
Similarly, B is not destroyed either, because A.bptr still points to B.
As a result, both A and B keep each other alive ‚Äî neither's strong count ever reaches 0.

When main() ends (weak_ptr version ‚Äî no circular dependency):
b goes out of scope ‚Üí shared_ptr<B> destructor runs ‚Üí B strong count goes from 2 ‚Üí 1 (because A.bptr still holds one strong ref to B).
a goes out of scope ‚Üí shared_ptr<A> destructor runs ‚Üí A strong count goes from 1 ‚Üí 0 ‚Üí A is destroyed.
when A is destroyed ‚Üí its member bptr (shared_ptr<B>) is destroyed ‚Üí bptr destructor executes --> decreases B strong count from 1 ‚Üí 0.
since B strong count became 0 ‚Üí B is destroyed.


40) Static Members:
What is static data member?
A static data member is a variable that is shared among all instances of a class. It belongs to the class itself rather than to any specific object of the class. This means that there is only one copy of the static data member, regardless of how many objects of the class are created.

All static members are initialized to zero by default if not explicitly initialized.

By declaration inside the class, we are just informing the compiler about its existence and type, but not allocating any storage for it.
By defining it outside we are telling the compiler to allocate storage for that static member variable only once, at the global scope. 

If you define it inside the class, the compiler would have to allocate storage every time an object is created, leading to multiple copies of the same variable. If a static member is defined in a header file class included by multiple files, the linker sees multiple definitions ‚Üí ODR violation ‚Üí linker error.

The One Definition Rule (ODR) states that in a C++ program, each variable, function, class, or template must have exactly one definition across the entire program, though it may have multiple declarations.

We can define [static members] inside the class only :
if they are integral const (pre-C++17), or if we use inline (C++17 and later). Inline will allow the definition to be present in multiple translation units without violating ODR, because the compiler/linker will ensure that only one instance exists.

Integral constants are compile-time numbers embedded into instructions. They live in the .text segment if unused for their address, and only become real memory objects if their address is needed.

inline ensures that even if included in multiple .cpp files, the linker merges them into one object.

Static member functions:
A static member function is a function that belongs to the class itself rather than to any specific object. 
We can call static member functions without creating an instance of the class and accessed using the class name and the scope resolution operator (::).

A static member function can only access static data members and other static member functions of the class. It cannot access non-static members because it does not have a `this` pointer, which refers to a specific object instance.

You could call a static member function using an object of the class, but it's not recommended because it can be misleading. It suggests that the function is tied to that specific object, which is not the case.

41) Friend Functions and Classes:
A friend function is a non-member function that has access to private and protected members of a class. It is declared using the `friend` keyword inside the class definition.

Used when an external function needs to work closely with a class.
Eg: operator overloading functions for << and >> operators.

A friend class is a class that has access to the private and protected members of another class.

class Engine; 
class Car {
    friend class Engine; // Engine is a friend class of Car
private:
    int horsepower;
};
class Engine {
public:
    void displayHorsepower(Car& car) {
        cout << "Horsepower: " << car.horsepower << endl; // Accessing private member of Car
    }
};
int main() {
    Car myCar;
    Engine myEngine;
    myEngine.displayHorsepower(myCar); // Valid: Engine can access Car's private members
    return 0;
}

42) Lambda Function::
A lambda function is an anonymous (unnamed) function that can be defined and used inline ‚Äî often inside another function.
inline means defined at the point of use, not separately named and defined elsewhere.

It's mainly used for short, simple operations without needing a separate function definition.
Introduced in C++11.
All parts are optional except the capture list and function body.
Basic syntax:
[capture list](parameters) -> return_type {
    // function body
};


| Capture Type             | Syntax | Meaning                                                 |
| ------------------------ | ------ | ------------------------------------------------------- |
| Capture by Value         | `[x]`  | Copies variable `x` inside the lambda                   |
| Capture by Reference     | `[&x]` | Refers to actual variable `x` (changes affect original) |
| Capture All by Value     | `[=]`  | Copies all external variables used in the lambda        |
| Capture All by Reference | `[&]`  | Refers to all external variables used in the lambda     |

Eg:
int x = 10, y = 20;

auto sum1 = [=]() { return x + y; };    // capture by value
auto sum2 = [&]() { return ++x + y; };  // capture by reference (x changes)

cout << sum1() << endl;  // 30
cout << sum2() << endl;  // 31, and x becomes 11

cout << [](int a, int b) { return a + b; }(5, 3); << endl; // 8
// With return type
auto getIndex = [](char c) -> int {
    if (isalpha(c)) return c - 'a';       // 0‚Äì25 for letters
    else if (isdigit(c)) return 26 + (c - '0'); // 26‚Äì35 for digits
    else return -1; // ignore others
};

// Without parameters
auto greet = [] { cout << "Hello Lambda!"; };
greet(); // Outputs: Hello Lambda!

43) Exception Handling:
Exception handling in C++ is a mechanism that allows you to handle runtime errors gracefully without crashing the program. It uses three main keywords: `try`, `catch`, and `throw`.
1. try block: Contains the code that may throw an exception.
2. throw statement: Used to signal that an exception has occurred.
3. catch block: Contains the code that handles the exception.

Use <exception> header for standard exceptions. It provides the base std::exception class, which doesn't give much detail about the nature of the error.

<stdexcept> provides more specialized exceptions, like std::invalid_argument, std::out_of_range, std::logic_error, and std::runtime_error. These exceptions allow you to handle different error conditions more specifically.

We can catch exception specializations like std::runtime_error before catching the general std::exception to provide more specific error handling.

e.what() returns a C-style string (const char*) that describes the error. It is a virtual function defined in the std::exception class and overridden in derived exception classes to provide specific error messages.

We need to use reference(&) in catch blocks to avoid object slicing. Ensures polymorphism works, so derived class exceptions are caught correctly.

Object slicing occurs when an object of a derived class is assigned to a base class object. The derived class-specific attributes and behaviors are "sliced off," leaving only the base class part. This can lead to loss of information and unexpected behavior, especially when dealing with exceptions. This is avoided by catching exceptions by reference because it preserves the actual object type.

#include <stdexcept>  // For specific runtime_error exceptions
#include <iostream>
#include <exception>  // For std::exception

void testFunction() {
    // Throwing a runtime error: something went wrong at runtime
    throw std::runtime_error("A runtime error occurred!");
}

class MyCustomException : public std::exception {
public:
    const char* what() const noexcept override {
        return "My custom exception occurred!";
    }
};

void testCustomException() {
    throw MyCustomException();
}

int main() {
    try {
        testFunction();  // Calling the function that throws a runtime error
        testCustomException(); // Calling the function that throws a custom exception
    } catch (const std::runtime_error& e) {
        // Catching the runtime error specifically
        std::cout << "Caught runtime error: " << e.what() << std::endl;
    } catch (const std::exception& e) {
        // Catching other general exceptions if needed
        std::cout << "Caught some other exception: " << e.what() << std::endl;
    } catch (...) {
        // Catching any other exceptions not previously caught
        std::cout << "Caught an unknown exception!" << std::endl;
    }

    return 0;
}

44) using:
The `using` keyword in C++ serves multiple purposes, primarily for type aliasing and namespace management.
1. Type Alias:
The `using` keyword can create type aliases, which are alternative names for existing types. This can make code more readable and easier to maintain.
using IntPtr = int*; // Alias for int pointer
Earlier we haves used typedef for type aliasing:
typedef int* IntPtr; // Alias for int pointer
Both are equivalent, but `using` is often preferred for its clarity, especially with complex types like templates. Because it can automatically deduce template parameters but for typedefs, you have to specify them explicitly.
template <typename T>
using Vec = std::vector<T>; // Alias for vector of type T

For typedef:
typedef std::vector<int> IntVector; // Alias for vector of integers

2. Namespace Management:
The `using` keyword can bring specific names from a namespace into the current scope, so you can use it without having to prefix it with the namespace name.
using std::cout;
It is either selectively imports specific names from a namespace into the current scope or brings all names from a namespace into the current scope.

3. Using Declarations in Classes:
When a derived class defines a function with the same name as one in the base class, it hides all overloads of that function from the base class (even if the parameters differ) because name lookup stops at the derived class level because
The `using` keyword can be used in derived classes to bring base class members into the derived class scope, allowing access to overloaded functions from the base class.
class Base {
public:
    void display(int x) {
        std::cout << "Base display: " << x << std::endl;
    }
};
class Derived : public Base {
public:
    using Base::display; // Bring Base class display into Derived class scope
    void display(std::string str) {
        std::cout << "Derived display: " << str << std::endl;
    }
};

4. Enum Import:
C++20 allows using enum to bring enumerators into scope.
    enum class Color { Red, Green, Blue };
    using enum Color; // now we can use Red, Green, Blue directly
    Color c = Red;

45) namespace:
In C++, namespace is a way to group related code together and avoid name collisions. It provides a scope for identifiers (like variables, functions, classes) to prevent naming conflicts, especially in large projects or when using multiple libraries.

Scope means where a name(variable, function, class etc.) is visible and accessible.

You can avoid namespace prefix everytime by using, using namespace <namespace_name> 

But be careful, using namespace std; in headers or large projects because it brings all names from std into global scope can lead to name conflicts and ambiguities.
Eg: Your user defined count function may conflict with std::count

Instead, prefer explicit usage (std::cout) or selective using declarations (using std::cout)

The scope resolution operator(::) is used to tell the complier which namespace's version you want to use.

46) Standard Template Library (STL):
STL (Standard Template Library) in C++ is a set of template classes and functions that provides ready-made data structures (containers), algorithms, and iterators.
It allows developers to write efficient and clean code without implementing these structures from scratch.
1. Containers: 
A container in STL is a class template that stores and manages a collection of elements in a specific data structure according to the requirements.
Containers are objects that hold data in a structured way (like arrays, lists, sets, maps) in the STL.
Types of containers:
a) Sequence Containers: Store elements in a linear order.
Examples: std::vector, std::list, std::deque, std::array, std::forward_list
b) Container Adapters: Provide a specific interface for certain data structures. They are built on top of other sequence containers and restrict access to certain operati  ns to provide a specific behavior.
Examples: std::stack, std::queue, std::priority_queue
c) Associative Containers: Store elements in such a way that they are always kept in sorted order using a balanced tree structure.  All are implemented using Red-Black trees ‚Üí O(log N) time complexity for search, insert, delete.
Examples: std::set, std::map, std::multiset, std::multimap
d) Unordered Associative Containers: Store elements in an unordered manner using hash tables for fast access.  O(1) average time complexity for search, insert, delete.
Examples: std::unordered_set, std::unordered_map, std::unordered_multiset, std::unordered_multimap

2. Algorithms:
Algorithms in STL are a collection of functions that operate on containers to perform various operations like searching, sorting, and manipulating data.
Examples: std::sort, std::find, std::accumulate, std::copy, std::transform
Types of Algorithms:
a) Non-modifying algorithms: Do not change the contents of the container (e.g., std::find, std::count).
b) Modifying algorithms: Change the contents of the container (e.g., std::fill, std::reverse).
c) Sorting algorithms: Specifically designed to sort elements in a container (e.g., std::sort, std::stable_sort).
d) Numeric algorithms: Perform mathematical operations on numeric data (e.g., std::accumulate, std::inner_product).
e) Searching algorithms: Find elements in a container (e.g., std::binary_search, std::find_if).

3. Iterators:
Iterators in STL are objects that provide a way to access and traverse the elements of a container. They act as a bridge between algorithms and containers, allowing algorithms to work with different types of containers in a uniform way.
Types of Iterators:
a) Input Iterators: Can read data from a container (one-way). Eg: istream_iterator
b) Output Iterators: Can write data to a container (one-way). Eg: ostream_iterator
c) Forward Iterators: Can read/write data and move forward through a container (one-way
d) Bidirectional Iterators: Can read/write data and move both forward and backward through a container (two-way).
e) Random Access Iterators: Can read/write data and move freely to any position in a container (like pointers).

4. Functors:
Functors (function objects) in STL are objects that can be treated as functions. They are created by overloading the operator() in a class.
Functors can maintain state and can be passed as arguments to algorithms, allowing for more flexible and customizable behavior.

a) Sequence Containers:
1) std::vector:
A dynamic array that can resize itself automatically when elements are added or removed. Elements are stored in contiguous memory locations, allowing for efficient access using indices. 
Support random access iterators means you can access elements directly using their index.

Ideal for scenarios where frequent access to elements by index is required.

Commonly used member functions of std::vector:
a) push_back(): Adds an element to the end of the vector.
b) pop_back(): Removes the last element from the vector. Calling pop_back() on an empty vector is illegal.
c) size(): Returns the number of elements in the vector.
d) capacity(): Returns the total number of elements that can be held in currently allocated storage.
e) front() and back(): Access the first and last elements of the vector.
f) at(index): Access element at specified index with bounds checking.
g) clear(): Removes all elements from the vector.
h) erase(): Removes elements from a specified position or range.
i) insert(): Inserts elements at a specified position.
v.insert(position_iterator, value); // v.insert(v.begin() + 2, 3);  // Insert 3 at index 2
v.insert(position_iterator, n, value); // v.insert(v.begin(), 2, 0);  // Insert 0 two times at the beginning
v.insert(position_iterator, first_iterator, last_iterator); // v.insert(v.end(), v2.begin(), v2.end());

Time Complexity for std::vector:
Access: O(1)
Insertion at end: Amortized O(1)
Insertion/Deletion: O(N) (due to shifting elements)

2) std::list:
A list is a sequential container implemented as a doubly linked list.
A double linked list consists of nodes where each node contains data and two pointers: one pointing to the next node and another pointing to the previous node.
It allows efficient insertion and deletion of elements at any position in the list.
Elements are not stored in contiguous memory locations.

Supports bidirectional iterators means you can traverse the list in both directions (forward and backward).

Ideal for scenarios where frequent insertions and deletions are required.


Commonly used member functions of std::list:
a) push_back() and push_front(): Adds an element to the end or beginning of the list.
b) pop_back() and pop_front(): Removes the last or first element from the list.
c) insert(): Inserts an element at a specified position.
d) erase(): Removes an element from a specified position.
e) front() and back(): Access the first and last elements of the list.
f) empty(): Checks if the list is empty.
Time Complexity for std::list:
Access: O(N) (no random access)
Insertion/Deletion: O(1) (given an iterator to the position)

3) std::deque:

A deque is a dynamic container that allows fast insertion and deletion at both ends
A double-ended queue that allows efficient insertion and deletion of elements from both ends (front and back) and provides random access to elements. Elements are stored in multiple fixed-size blocks rather than a single contiguous block, providing fast insertion and deletion at both ends while still allowing constant-time random access to elements.

Unlike a vector, which uses a single contiguous block, a deque stores elements in multiple small blocks. This allows fast insertion and deletion at both ends without copying all elements. Since ff capacity is exceeded, the entire array must be copied to a new larger block ‚Üí expensive for vectors.

By using multiple blocks, a deque avoids shifting all elements for front/back operations and only allocates/deallocates small blocks as needed, making front/back insertion and deletion O(1).

Ideal for scenarios where frequent insertions and deletions are required at both ends of the container and random access is also needed.
Commonly used member functions of std::deque:
a) push_back() and push_front(): Adds an element to the end or beginning of the deque.
b) pop_back() and pop_front(): Removes the last or first element from the deque.
c) at(index): Access element at specified index with bounds checking.
d) insert(): Inserts an element at a specified position.
e) erase(): Removes an element from a specified position.
f) front() and back(): Access the first and last elements of the deque.
Time Complexity for std::deque:
Access: O(1)
Insertion/Deletion at both ends: O(1)

Diff between vector and deque:
| Feature               | std::vector                      | std::deque                                   |
|-----------------------|----------------------------------|-----------------------------------           |    
| Memory Structure      | Contiguous memory                | Dynamic array of fixed-size arrays           |
| Insertion/Deletion    | Efficient at end (amortized O(1))| Efficient at both ends (O(1))                |
| Random Access         | Yes (O(1))                       | Yes (O(1))                                   |
| Memory Reallocation   | May require reallocation         | Less frequent reallocation                   |
| Cache Locality        | Better due to contiguous storage | Slightly worse due to non-contiguous storage |

4) forward_list:
A forward_list is a sequential container implemented as a singly linked list.
A singly linked list consists of nodes where each node contains data and a pointer to the next node in the sequence, providing very fast
insertion and deletion of elements at the front and after any given position, while using minimal memory overhead.

Ideal for scenarios where memory efficiency is crucial and frequent insertions and deletions are required at the front or after specific positions in the list.
Commonly used member functions of std::forward_list:
a) push_front(): Adds an element to the beginning of the list.
b) pop_front(): Removes the first element from the list.
c) insert_after(): Inserts an element after a specified position.
d) erase_after(): Removes an element after a specified position.    
e) front(): Access the first element of the list.
f) l1.splice_after(pos, l2, first_iterator, last_iterator): Transfers elements from l2 to l1 after position pos.
g) merge(): Merges two sorted forward_lists into one sorted list.
h) sort(): Sorts the elements in the forward_list.

Time Complexity for std::forward_list:
Access: O(N) (no random access)
Insertion/Deletion: O(1) (given an iterator to the position)

5) std::array:
A std::array is a fixed-size container that encapsulates fixed-size arrays. It provides a safer and more convenient alternative to traditional C-style arrays because it offers member functions for easier manipulation and access of elements.

The size of a std::array must be known at compile time and cannot be changed at runtime

Ideal for scenarios where the size of the array is known at compile time and does not need to change.

Commonly used member functions of std::array:
a) at(index): Access element at specified index with bounds checking.   
b) size(): Returns the number of elements in the array. // Cannot be array decayed to pointer   
c) front() and back(): Access the first and last elements of the array.
d) fill(value): Fills the array with the specified value.
e) swap(other_array): Swaps the contents of two arrays.
f) data(): Returns a pointer to the underlying array.

Array decay is the implicit conversion of a C-style array to a pointer to its first element. This happens in most expressions, such as when an array is passed to a function.
When an array decays, it loses its size information.
Only a pointer to the first element remains (T*).
This is why sizeof(array) inside a function often gives the size of a pointer, not the array.

Time Complexity for std::array:
Access: O(1)
Insertion/Deletion: O(N) (due to shifting elements)

b) Container Adapters:
A container adapter is a type of class template that provides a specific interface for an underlying container, often modifying or restricting its behavior to fit certain patterns.
They are built on top of other sequence containers and restrict access to certain operations to provide a specific behavior.

1) std::stack:
A stack allows you to add and remove elements in a "last in, first out" (LIFO) order.
Key Operations:
push(): Adds an element to the top of the stack.
pop(): Removes the element from the top of the stack.
top(): Returns the top element of the stack.
empty(): Returns whether the stack is empty.
size(): Returns the number of elements in the stack.

2) std::queue:
A queue allows you to add and remove elements in a "first in, first out" (FIFO) order.
Key Operations:
push(): Adds an element to the back of the queue.
pop(): Removes the element from the front of the queue.
front(): Returns the front element of the queue.
back(): Returns the last element of the queue.
empty(): Returns whether the queue is empty.
size(): Returns the number of elements in the queue.

3) std::priority_queue:
A priority queue stores elements in a way that the highest (or lowest) priority element is always accessible at the top. By default, it stores elements in descending order (highest first).

Key Operations:
push(): Adds an element to the priority queue.
pop(): Removes the highest priority element from the queue.
top(): Returns the highest priority element of the queue.
empty(): Returns whether the priority queue is empty.
size(): Returns the number of elements in the priority queue.

| Adapter               | Default Container | Allowed Containers                                        |
| --------------------- | ----------------- | --------------------------------------------------------- |
| `std::stack`          | `std::deque<T>`   | `std::vector<T>`, `std::deque<T>`, `std::list<T>`         |
| `std::queue`          | `std::deque<T>`   | `std::deque<T>`, `std::list<T>`                           |
| `std::priority_queue` | `std::vector<T>`  | Any random-access container (usually `vector` or `deque`) |

std::stack and std::queue do not provide iterators to traverse their elements because they are designed to restrict access to only the top (for stack) or front/back (for queue) elements, adhering to their LIFO and FIFO principles respectively. Allowing iteration would violate these principles by exposing all elements. 

Ideal for scenarios where you need to manage data in a specific order (LIFO for stack, FIFO for queue) without exposing the underlying structure.

container_adapter_name<element_type, underlying_container_type> adapter_name;
Eg: 
std::stack<int, std::vector<int>> myStack; // Stack using vector as underlying container

Using compartor with priority_queue:
std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap; // Min-heap


c) Associative Containers:
Associative containers are a type of container classes that store elements in a way that allows fast retrieval based on keys. They automatically maintain the order of elements based on the keys.

They are typically implemented using balanced binary search trees (like Red-Black trees) to ensure that elements are always sorted based on their keys.

1) std::set:
A set is a collection of unique elements stored in a sorted order.
Elements are typically sorted using the < operator or a custom comparator.

struct Descending {
    bool operator()(int a, int b) const {
        return a > b; // reverse order
    }
};

std::set<int, Descending> s = {1, 2, 3};

Time Complexity for std::set:
Search: O(log N)
Insertion: O(log N)
Deletion: O(log N)

2) std::map:
A map is a collection of key-value pairs, where each key is unique and maps to a specific value in a sorted order.

struct Descending {
    bool operator()(int a, int b) const {
        return a > b; // reverse order
    }
};
std::map<int, std::string, Descending> m;

Time Complexity for std::map:
Search: O(log N)    
Insertion: O(log N)
Deletion: O(log N)

3) std::multiset:
A multiset is similar to a set, but it allows multiple occurrences of the same element.

Time Complexity for std::multiset:
Search: O(log N)    
Insertion: O(log N)
Deletion: O(log N)

4) std::multimap:
A multimap is similar to a map, but it allows multiple key-value pairs with the same key.

In a normal map, each key must be unique ‚Äî inserting another pair with the same key replaces the old value.

Time Complexity for std::multimap:
Search: O(log N)
Insertion: O(log N)
Deletion: O(log N)

d) Unordered Associative Containers:

Unordered associative containers store elements in an unordered manner using hash tables for fast access. They provide average O(1) time complexity for search, insert, and delete operations.
1) std::unordered_set:
A unordered_set is a collection of unique elements stored in an unordered manner using hash tables.

Time Complexity for std::unordered_set:
Search: O(1) average
Insertion: O(1) average
Deletion: O(1) average
2) std::unordered_map:
An unordered_map is a collection of key-value pairs stored in an unordered manner using hash tables.

Time Complexity for std::unordered_map:
Search: O(1) average
Insertion: O(1) average
Deletion: O(1) average
3) std::unordered_multiset:
An unordered_multiset is similar to an unordered_set, but it allows multiple occurrences of the same element.

Time Complexity for std::unordered_multiset:
Search: O(1) average
Insertion: O(1) average
Deletion: O(1) average
4) std::unordered_multimap:
An unordered_multimap is similar to an unordered_map, but it allows multiple key-value pairs with the same key.

Time Complexity for std::unordered_multimap:
Search: O(1) average
Insertion: O(1) average
Deletion: O(1) average

2) Algorithms:
Algorithms in STL are a collection of functions that operate on containers to perform various operations like searching, sorting, and manipulating data.
Examples: std::sort, std::find, std::accumulate, std::copy, std::transform

a) Non-modifying algorithms: Do not change the contents of the container (e.g., std::all_of, std::count).
Eg: 
int c = count(v.begin(), v.end(), 5); // counts occurrences of 5 in vector v

bool ok = all_of(v.begin(), v.end(), [](int x){ return x > 0; }); // checks if all elements are positive

for_each(v.begin(), v.end(), [](int &x){ cout << x << " "; }); // prints all elements in vector v

b) Modifying algorithms: Change the contents of the container (e.g., std::fill, std::reverse).
Eg:
fill(v.begin(), v.end(), 0); // fills all elements in vector v with 0
reverse(v.begin(), v.end()); // reverses the order of elements in vector v
replace(v.begin(), v.end(), 3, 99); // replace 3 ‚Üí 99
c) Sorting algorithms: Specifically designed to sort elements in a container (e.g., std::sort, std::stable_sort).
Eg:
sort(v.begin(), v.end()); // sorts vector v in ascending order
(1, 2, 3a, 3b)  ‚Üê order of a then b is kept
std::stable_sort(v.begin(), v.end());
std::partial_sort(v.begin(), v.begin() + k, v.end()); // sorts first k elements in vector v
d) Numeric algorithms: Perform mathematical operations on numeric data (e.g., std::accumulate, std::inner_product).
Eg:
int sum = accumulate(v.begin(), v.end(), 0); // calculates the sum of all elements in vector v
std::string s = "hello";
std::string out(s.size());

std::transform(s.begin(), s.end(), out.begin(), ::toupper);
// converts all characters in string s to uppercase and stores in out
each(v.begin(), v.end(), [](int &x){ x *= 2; }); // doubles each element in vector v

vector<int> v2 = {1, 2, 3, 4};
vector<int> diff(v.size());
adjacent_difference(v.begin(), v.end(), diff.begin()); // computes the difference between adjacent elements in vector v and stores in diff

e) Searching algorithms: Find elements in a container (e.g., std::binary_search, std::find_if).
Eg:
bool found = binary_search(v.begin(), v.end(), 5); // checks if 5 is present in sorted vector v

auto it = find(v.begin(), v.end(), 4);
if(it != v.end()) cout << "Found";    // checks if 4 is present in vector v

auto it = find_if(v.begin(), v.end(), [](int x){ return x > 10; }); // finds first element greater than 10 in vector v
3) Iterators:
Iterators are objects that act like pointers. They are used to traverse containers (vector, list, map, set, etc.).

Think of iterators as a ‚Äúgeneralized pointer‚Äù that works with any STL container.

Why do we need Iterators?
Because each STL container has a different internal structure, but iterators give a common interface to access them.So same code works for vector, list, set, map.

So you don't need to know how a container is implemented.

| Iterator Type | Operations Allowed                          | Example Containers          |
| ------------- | ------------------------------------------- | --------------------------- |
| Input         | read, forward only                          | istream_iterator            |
| Output        | write, forward only                         | ostream_iterator            |
| Forward       | read/write, forward only                    | forward_list, unordered_*   |
| Bidirectional | read/write, forward/backward                | list, set, map              |
| Random Access | read/write, forward/backward, jump `+,-,[]` | vector, deque, array        |

Reads values from input streams (keyboard, file).
std::istream_iterator<int> in(std::cin);
std::istream_iterator<int> end;
std::vector<int> v(in, end); // reads input into vector

end is a default-constructed iterator representing the end of the stream.

//Writes values to output streams (console, file).
std::ostream_iterator<int> out(std::cout, " ");
std::copy(v.begin(), v.end(), out);

std::copy(source_begin, source_end, destination);
std::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, " "));

Creates an output iterator that calls push_back() on a container.
Useful when destination container is empty or doesn't have pre-allocated space.
Appends elements at the end of the container.
Useful for containers like std::vector, std::list, std::deque if we don't know the final size in advance.

std::copy(a.begin(), a.end(), std::back_inserter(b));

4) Functors:
A functor (function object) is any object that can be called like a function. This is done by overloading the operator() in a class.
You can create instances of the class and use them like functions.
It can safely store state (data members) and can be passed as arguments to algorithms, allowing for more flexible and customizable behavior.

Eg:

struct Add {
    int operator()(int a, int b) const {
        return a + b;
    }
};  
Add add;
int result = add(3, 5); // Calls Add::operator()(3, 5)

#include <vector>
#include <algorithm>
#include <iostream>

class Square {
public:
    void operator()(int &x) { x = x * x; }
};

int main() {
    std::vector<int> v = {1, 2, 3, 4};

    std::for_each(v.begin(), v.end(), Square());

    for (int x : v)
        std::cout << x << " ";  // 1 4 9 16
}





C++ makes a special exception for this case:
You can bind a "const &" to a temporary (rvalue) which means you cannot modify the temporary through that reference.

For non const references, you cannot bind them to temporaries (rvalues) because non-const references imply that you might modify the object they refer to. Since temporaries are meant to be short-lived and are often stored in read-only memory, allowing modification through a non-const reference would lead to undefined behavior.
Modifying a temporary that's about to disappear would be nonsense.

How std::move works internally:
Consider the following example:
      lvalue 'a'
          |
          v
   std::move(a) called
          |
          v
  Template deduction:
  T&& t, a is lvalue
  => T = UniquePtr&
  => T&& = UniquePtr&  (reference collapsing)
          |
          v
 std::remove_reference<T>::type
  => remove & ‚Üí UniquePtr
          |
          v
 static_cast<UniquePtr&&>(t)
          |
          v
      rvalue reference (UniquePtr&&)
      It will call the move constructor 
          |
          v
   Move constructor called
          |
          v
Ownership transferred:
 a.ptr = nullptr
 b.ptr = resource


