1) enum class:
#include <iostream>
using namespace std;

enum class Gender {
    Male,
    Female
};

struct Data {
    string name;
    int age;
    Gender gender;
};

string getGenderString(Gender g) {
    return (g == Gender::Male) ? "Male" : "Female";
}

int main() {
    Data person = {"Alice", 62, Gender::Female};

    cout << "Name: " << person.name
         << ", Age: " << person.age
         << ", Gender: " << getGenderString(person.gender) << endl;

    return 0;
}

2) enum with switch statement:
#include <iostream>
using namespace std;

enum Weather { SUNNY, CLOUDY, RAINY };

string getWeatherName(Weather w) {
    switch (w) {
        case SUNNY: return "Sunny";
        case CLOUDY: return "Cloudy";
        case RAINY: return "Rainy";
        default: return "Unknown";
    }
}

int main() {
    Weather w = CLOUDY;
    cout << "Weather: " << getWeatherName(w) << endl;

    return 0;
}

3) enum with bitwise operations:
#include <iostream>
using namespace std;

enum class Permissions {
    None    = 0,
    Read    = 1 << 0,   // 0001
    Write   = 1 << 1,   // 0010
    Execute = 1 << 2    // 0100
};

// Overload bitwise OR
inline Permissions operator|(Permissions lhs, Permissions rhs) {
    return static_cast<Permissions>(
        static_cast<int>(lhs) | static_cast<int>(rhs)
    );
}

// Overload bitwise AND
inline int operator&(Permissions lhs, Permissions rhs) {
    return static_cast<int>(lhs) & static_cast<int>(rhs);
}

struct File {
    string name;
    Permissions permissions;
};

string getPermissionsString(Permissions p) {
    string result;
    if (p & Permissions::Read)    result += "Read ";
    if (p & Permissions::Write)   result += "Write ";
    if (p & Permissions::Execute) result += "Execute ";
    return result.empty() ? "None" : result;
}

int main() {
    File file = {"example.txt", Permissions::Read | Permissions::Write};

    cout << "File: " << file.name
         << ", Permissions: " << getPermissionsString(file.permissions) << endl;

    return 0;
}

4) Structure:
#include <iostream>
#include <vector>
using namespace std;

// Struct to hold student data
struct Student {
    int rollNo;
    string name;
    float marks;
};

// Class to manage students
class StudentManager {
private:
    vector<Student> students;

public:
    void addStudent(int roll, string name, float marks) {
        students.push_back({roll, name, marks});
    }

    void displayAll() {
        cout << "\n--- Student List ---\n";
        for (const auto& s : students) {
            cout << "Roll No: " << s.rollNo
                 << ", Name: " << s.name
                 << ", Marks: " << s.marks << endl;
        }
    }

    float calculateAverage() {
        if (students.empty()) return 0;
        float total = 0;
        for (const auto& s : students)
            total += s.marks;
        return total / students.size();
    }
};

int main() {
    StudentManager manager;

    // Add students
    manager.addStudent(101, "Alice", 85.5);
    manager.addStudent(102, "Bob", 78.0);
    manager.addStudent(103, "Charlie", 92.3);

    // Display all students
    manager.displayAll();

    // Show average marks
    cout << "\nAverage Marks: " << manager.calculateAverage() << endl;

    return 0;
}

5) Basic Structure:
#include <iostream>
using namespace std;

// Define a structure
struct Person {
    string name;
    int age;
};

int main() {
    // Declare and initialize a structure variable
    Person p;

    cout << "Enter age: ";
    cin >> p.age;

    // Clear leftover newline before using getline
    cin.ignore(); // Very important!

    // Get input from user
    cout << "Enter name: ";
    getline(cin, p.name);

    // Display the data
    cout << "\n--- Person Info ---\n";
    cout << "Name: " << p.name << endl;
    cout << "Age: " << p.age << endl;

    return 0;
}

6) Count the digits: 
int countDigits(int n) {
    int count=0;
    while(n>0) {
        n=n/10;
        count++;
    }
    return count;
}
or
int len=to_string(abs(str)).length();

7)Power with base:
int intPower(int base, int exp) {
    int result=1;

    for(int i=0;i<exp;i++)
    {
        result=result*i;
    }
    return result;
}
or
#include<cmath> int result=pow(base,exponent);

8)To filter single number at a time:
int revNumber(int n) {
    int rev=0;
    while(n>0) {
        int digit=n%10; // Get the last digit
        rev=rev*10+digit; // Add it to rev
        n=n/10; // Extract the last digit and add it to rev
    }
    return rev;
}

9) Reverse words in a sentence:
#include <iostream>
#include <sstream>
#include <algorithm>
using namespace std;

int main() {
    string sentence = "cat dog bat";
    stringstream ss(sentence);
    string word, result = "";
    bool first = true;

    while (ss >> word) {
        if (!first) result += " ";           // Add space *only after* the first word
        reverse(word.begin(), word.end());   // Reverse each word
        result += word;
        first = false;
    }

    cout << "Reversed words: " << result << endl;
    return 0;
}
//Reversed words: tac god tab

10) Youtube Channel Collection using operator overloading:
#include <iostream>
#include <list>
#include <algorithm>
#include <stdexcept>
using namespace std;

class YoutubeChannelCollection {
private:
    struct YoutubeChannel {
        string Name;
        int SubscribersCount;

        YoutubeChannel(string name = "", int count = 0)
            : Name(name), SubscribersCount(count) {}

        bool operator==(const YoutubeChannel& yt) const {
            return this->Name == yt.Name;
        }

        bool operator!=(const YoutubeChannel& yt) const {
            return !(*this == yt);
        }

        // Prefix increment: add 100 subscribers
        YoutubeChannel& operator++() {
            SubscribersCount += 100;
            return *this;
        }

        // Postfix increment
        YoutubeChannel operator++(int) {
            YoutubeChannel temp = *this;
            ++(*this);
            return temp;
        }

        // Boolean conversion
        operator bool() const {
            return SubscribersCount > 0;
        }

        // Stream output
        friend ostream& operator<<(ostream& out, const YoutubeChannel& yt) {
            out << "YoutubeName: " << yt.Name
                << ", Subscribers: " << yt.SubscribersCount << endl;
            return out;
        }

        // Stream input
        friend istream& operator>>(istream& in, YoutubeChannel& yt) {
            cout << "Enter channel name: ";
            getline(in, yt.Name);
            cout << "Enter subscriber count: ";
            in >> yt.SubscribersCount;
            in.ignore();
            return in;
        }
    };

    list<YoutubeChannel> channels;

public:
    // Add channel
    void operator+=(const string& name) {
        channels.emplace_back(name, 0);
    }

    void operator+=(const YoutubeChannel& channel) {
        channels.push_back(channel);
    }

    // Merge collections
    YoutubeChannelCollection& operator+=(const YoutubeChannelCollection& other) {
        for (const auto& ch : other.channels) {
            if (find(channels.begin(), channels.end(), ch) == channels.end())
                channels.push_back(ch);
        }
        return *this;
    }

    // Remove channel by name
    void operator-=(const string& name) {
        channels.remove_if([&](const YoutubeChannel& ch) { return ch.Name == name; });
    }

    // Binary + merge
    YoutubeChannelCollection operator+(const YoutubeChannelCollection& other) const {
        YoutubeChannelCollection result = *this;
        result += other;
        return result;
    }

    // Binary - subtract
    YoutubeChannelCollection operator-(const YoutubeChannelCollection& other) const {
        YoutubeChannelCollection result = *this;
        for (const auto& ch : other.channels)
            result -= ch.Name;
        return result;
    }

    // Equality
    bool operator==(const YoutubeChannelCollection& other) const {
        return channels == other.channels;
    }

    // Index access
    YoutubeChannel& operator[](int index) {
        auto it = channels.begin();
        advance(it, index);
        return *it;
    }

    const YoutubeChannel& operator[](int index) const {
        auto it = channels.begin();
        advance(it, index);
        if (it == channels.end()) throw out_of_range("Index out of range");
        return *it;
    }

    // Search by name
    YoutubeChannel* operator()(const string& name) {
        for (auto& ch : channels) {
            if (ch.Name == name)
                return &ch;
        }
        return nullptr;
    }

    // Logical NOT
    bool operator!() const {
        return channels.empty();
    }

    // Stream output
    friend ostream& operator<<(ostream& out, const YoutubeChannelCollection& col) {
        if (col.channels.empty())
            out << "Collection is empty.\n";
        else
            for (const auto& ch : col.channels)
                out << ch;
        return out;
    }
};

int main() {
    YoutubeChannelCollection col1, col2;

    // Add channels
    col1 += "AlphaTech";
    col1 += "BetaScience";
    col2 += "GammaGaming";

    cout << "Collection 1:\n" << col1;
    cout << "Collection 2:\n" << col2;

    // Merge collections
    auto merged = col1 + col2;
    cout << "\nMerged Collection:\n" << merged;

    // Subtract collections
    auto removed = merged - col2;
    cout << "\nAfter Subtraction:\n" << removed;

    // Index access and increment
    ++col1[0];   // prefix increment
    col1[1]++;   // postfix increment
    cout << "\nAfter increment:\n" << col1;

    // Search by name
    auto found = merged("BetaScience");
    if (found)
        cout << "\nFound: " << *found;

    // Logical NOT
    if (!YoutubeChannelCollection())
        cout << "\nEmpty collection detected.\n";

    return 0;
}

11) For Better Understanding:
// Online C++ compiler to run C++ program online
#include <iostream>
using namespace std;
class Light {
public:
    bool isOn = false;

    bool operator!() const {
        return !isOn;  // ðŸ‘ˆ Checks this object's state
    }
};

int main() {
    Light lamp;
Light torch;
torch.isOn = true;
Light lamp;

if (!lamp) {
    cout << "Lamp is OFF\n";  // âœ… Runs because isOn is false, so !isOn is true
}

lamp.isOn = true;

if (!lamp) {
    cout << "Lamp is OFF\n";  // âŒ Doesnâ€™t run now, because isOn is true, so !isOn is false
}
//When you use !lamp,  the compiler actually does this: 
// if (lamp.operator!()) { ... }
// So operator!() is called on the object lamp.

    return 0;
}

12) Move Semantics in C++:
//Move Semantics
#include<iostream>
#include<string>
using namespace std;

class Movie {
    public:
    string Name;
    string Genre;
    float Rating;
    int ActorsCounters;
    string* Actors;

    Movie(string name, string genre, float rating):Name(name), Genre(genre),Rating(rating),ActorsCounters(0),Actors(nullptr)
    {
        cout<<"Constructor is called"<<endl;
    }

    ~Movie() {
        cout<<"Destructor is called"<<endl;
        delete[] Actors;
        Actors = nullptr;
    }

    Movie(const Movie& other) {
        Name = other.Name;
        Genre = other.Genre;
        Rating = other.Rating;
        ActorsCounters = other.ActorsCounters;
        Actors = new string[ActorsCounters];
        for(int i=0;i<ActorsCounters;i++) {
            Actors[i] = other.Actors[i];
        }   
    }

    Movie& operator=(const Movie& other) {
        if(this != &other) {
            delete[] Actors;
            Name = other.Name;
            Genre = other.Genre;
            Rating = other.Rating;
            ActorsCounters = other.ActorsCounters;
            Actors = new string[ActorsCounters];
            for(int i=0;i<ActorsCounters;i++) {
                Actors[i] = other.Actors[i];
            }   
        }
        return *this;
    }

    Movie (Movie&& other) noexcept {
        Name = other.Name;
        Genre = other.Genre;
        Rating = other.Rating;
        ActorsCounters = other.ActorsCounters;
        Actors = other.Actors;
        other.Actors = nullptr;
        other.ActorsCounters = 0;
        other.Rating = 0;

        cout << "Move Constructor called..\n";

    }

    Movie& operator=(Movie&& other) {
        if(this != &other) {
            delete[] Actors;
            Name = other.Name;
            Genre = other.Genre;
            Rating = other.Rating;
            ActorsCounters = other.ActorsCounters;
            Actors = other.Actors;
            other.Actors = nullptr;
            other.ActorsCounters = 0;
            other.Rating = 0;
            
            cout << "Move Assignment Operator called..\n";

        }
        return *this;
    }

    void PrintInfo() const {
        cout << "Name: " << Name << ", Genre: " << Genre << ", Rating: " << Rating << ", Actors: " << ActorsCounters << endl;
        for (int i = 0; i < ActorsCounters; i++) {
            cout << "  Actor " << i + 1 << ": " << Actors[i] << endl;
        }
        cout << endl;
    }

    void AddActor(const string Name) {
        string *newActors = new string[ActorsCounters+1];
        cout<<"ActorsCounters: "<<ActorsCounters<<endl;
        for (int i = 0;i<ActorsCounters;++i) {
            newActors[i] = Actors[i];
        }
        newActors[ActorsCounters] = Name;

        delete[] Actors;
        Actors = newActors;
        ActorsCounters++;
    }
};

int main() {
    Movie movie1("Peeyush", "Action", 9.7);
    movie1.AddActor("Yaswanth");
    movie1.AddActor("Sai");

    movie1.PrintInfo();

    Movie movie2(movie1);  // Copy constructor
    movie2.PrintInfo();

    Movie movie3("Mission Impossible", "Adventure", 9.3);
    movie3.PrintInfo();

    movie3 = movie1;       // Copy assignment
    movie3.PrintInfo();

    Movie movie4 = std::move(movie1); // Move constructor
    movie4.PrintInfo();

    Movie movie5("Temp", "Drama", 8.0);
    movie5 = std::move(movie2);       // Move assignment
    movie5.PrintInfo();

    // Optional: Print moved-from objects
    movie1.PrintInfo(); // Moved-from state
    movie2.PrintInfo(); // Moved-from state
}
