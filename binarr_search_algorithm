#include <iostream>
#include <vector>
using namespace std;

int binarySearch(vector<int> &arr, int target) {
    int start = 0, end = arr.size() - 1;
    while (start <= end) {
        int mid = start + (end - start) / 2;
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }
    return -1;
}

int countOccurrences(int arr[], int n, int key) {
    int start = 0, end = n - 1;
    int first = -1, last = -1;

    // ---- First Occurrence ----
    while (start <= end) {
        int mid = start + (end - start) / 2;
        if (arr[mid] == key) {
            first = mid;
            end = mid - 1; // keep searching left
        } else if (arr[mid] < key) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }

    if (first == -1)
        return 0; // element not found

    // ---- Last Occurrence ----
    start = 0;
    end = n - 1; // reset search space
    while (start <= end) {
        int mid = start + (end - start) / 2;
        if (arr[mid] == key) {
            last = mid;
            start = mid + 1; // keep searching right
        } else if (arr[mid] < key) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }

    return last - first + 1;
}

int floorSqrt(int n) {
    if (n == 0 || n == 1)
        return n;
    int low = 1, high = n / 2;

    while (low <= high) {
        long long mid = (low + high) / 2;
        long long val = (mid * mid);

        if (val <= n) {
            low = mid + 1; // move right
        } else {
            high = mid - 1; // move left
        }
    }

    return high; // floor of sqrt(n)
}

int peakIndexInMountainArray(vector<int> &arr) {
    int st = 1, end = arr.size() - 2; // avoid 0 and n-1

    while (st <= end) {
        int mid = st + (end - st) / 2;

        if (arr[mid - 1] < arr[mid] && arr[mid] > arr[mid + 1]) {
            return mid; // peak found
        } else if (arr[mid - 1] < arr[mid]) {
            st = mid + 1; // go right
        } else {
            end = mid - 1; // go left
        }
    }
    return -1; // should not happen in a valid mountain array
}

int searchRotatedArray(vector<int> &nums, int target) {
    int st = 0, end = nums.size() - 1;

    while (st <= end) {
        int mid = st + (end - st) / 2;

        if (nums[mid] == target)
            return mid;

        // Left side sorted
        if (nums[st] <= nums[mid]) {
            if (nums[st] <= target && target < nums[mid]) {
                end = mid - 1;
            } else {
                st = mid + 1;
            }
        }
        // Right side sorted
        else {
            if (nums[mid] < target && target <= nums[end]) {
                st = mid + 1;
            } else {
                end = mid - 1;
            }
        }
    }
    return -1;
}
/* 
| Case    | Time Complexity | Space Complexity                    |
| ------- | --------------- | ----------------------------------- |
| Best    | O(1)            | O(1) iterative / O(log n) recursive |
| Average | O(log n)        | O(1) iterative / O(log n) recursive |
| Worst   | O(log n)        | O(1) iterative / O(log n) recursive |
*/
int main() {
    int arr[] = {1, 2, 3, 3, 3, 5, 6};
    int n = sizeof(arr) / sizeof(arr[0]);
    int key = 3;

    cout << "Element " << key << " occurs " << countOccurrences(arr, n, key)
         << " times" << endl;
    int k = 339;
    cout << "Square root of " << k << " = " << floorSqrt(k) << endl;

    vector<int> arr1 = {1, 3, 5, 7, 6, 2};
    int peak = peakIndexInMountainArray(arr1);

    vector<int> rotated = {4, 5, 6, 7, 0, 1, 2};
    int idx = searchRotatedArray(rotated, 0);

    cout << "Peak is at Index: " << peak << ", Rotated array: " << idx << endl;

    vector<int> arr2 = {2, 4, 6, 8, 10, 12, 14};
    int target = 10;

    int result = binarySearch(arr2, target);

    if (result != -1)
        cout << "Element found at index: " << result << endl;
    else
        cout << "Element not found" << endl;

    return 0;
}
